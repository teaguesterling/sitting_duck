# name: test/sql/duckdb_native_parser.test
# description: Test DuckDB native parser capabilities vs tree-sitter
# group: [sitting_duck]

require sitting_duck

statement ok
LOAD sitting_duck;

# Test 1: Verify DuckDB language is available
# ===========================================

query I
SELECT language FROM ast_supported_languages() WHERE language = 'duckdb';
----
duckdb

# Test 2: Basic SELECT parsing accuracy (platform-tolerant)
# ==========================================================

query I
SELECT COUNT(DISTINCT type) >= 5 as has_expected_types
FROM parse_ast('SELECT user_id, COUNT(*) as total FROM orders GROUP BY user_id', 'duckdb')
WHERE type IN ('program', 'select_statement', 'select_node', 'column_reference', 'function_call', 'table_reference', 'group_by_clause');
----
1

# Test 3: CTE (WITH clause) parsing (platform-tolerant)
# ======================================================

query I
SELECT COUNT(*) >= 1 as has_select_statement
FROM parse_ast('
WITH regional_sales AS (
    SELECT region, SUM(sales) as total_sales
    FROM sales_data
    GROUP BY region
),
top_regions AS (
    SELECT region FROM regional_sales WHERE total_sales > 1000
)
SELECT * FROM top_regions
', 'duckdb')
WHERE type = 'select_statement';
----
1

# Test 4: Complex JOIN parsing (platform-tolerant)
# =================================================

query I
SELECT
    (SUM(CASE WHEN type = 'column_reference' THEN 1 ELSE 0 END) >= 2) AND
    (SUM(CASE WHEN type = 'table_reference' THEN 1 ELSE 0 END) >= 2) AND
    (SUM(CASE WHEN type = 'join' THEN 1 ELSE 0 END) >= 1) as has_join_structure
FROM parse_ast('
SELECT u.name, p.title, c.content
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
INNER JOIN comments c ON p.id = c.post_id
WHERE u.active = true
', 'duckdb');
----
1

# Test 5: Window functions and advanced SQL (platform-tolerant)
# ===============================================================

query I
SELECT
    SUM(CASE WHEN type = 'column_reference' THEN 1 ELSE 0 END) >= 1 AND
    SUM(CASE WHEN type = 'window_function' THEN 1 ELSE 0 END) >= 1 as has_window_functions
FROM parse_ast('
SELECT
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank,
    LAG(salary) OVER (ORDER BY hire_date) as prev_salary
FROM employees
', 'duckdb');
----
1

# Test 6: Semantic type accuracy for SQL constructs
# =================================================

query II
SELECT semantic_type_to_string(semantic_type) as semantic_type, COUNT(*) as count
FROM parse_ast('
INSERT INTO users (name, email) 
VALUES (''John'', ''john@example.com'')
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name
', 'duckdb')
GROUP BY semantic_type
ORDER BY semantic_type;
----
DEFINITION_MODULE	1
EXECUTION_MUTATION	1

# Test 7: Error handling with malformed SQL
# =========================================

query I
SELECT COUNT(*) FROM parse_ast('SELECT FROM WHERE', 'duckdb') WHERE type = 'parse_error';
----
1

# Test 8: DuckDB-specific functions and syntax
# ============================================

query II
SELECT type, name
FROM parse_ast('
SELECT 
    unnest([1,2,3]) as value,
    current_timestamp::date as today,
    ''hello world''::json->>''$.message'' as msg
FROM generate_series(1, 10)
', 'duckdb')
WHERE type = 'function_call'
ORDER BY name;
----
function_call	->>
function_call	unnest

# Test 9: Comparison with tree-sitter SQL parser (platform-tolerant)
# ====================================================================

query II
SELECT
    parser,
    total_nodes > 5 as has_reasonable_node_count
FROM (
    SELECT
        'duckdb' as parser,
        COUNT(*) as total_nodes
    FROM parse_ast('SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.a_id', 'duckdb')
    UNION ALL
    SELECT
        'tree-sitter' as parser,
        COUNT(*) as total_nodes
    FROM parse_ast('SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.a_id', 'sql')
) subq
ORDER BY parser;
----
duckdb	1
tree-sitter	1

# Test 10: Live query debugging capability (platform-tolerant)
# ==============================================================

query I
SELECT COUNT(*) >= 5 as has_minimum_nodes FROM parse_ast('SELECT COUNT(*) FROM users', 'duckdb');
----
1

# Test 11: Validate semantic type consistency
# ===========================================

query II
SELECT 
    get_super_kind(semantic_type) as super_kind,
    COUNT(*) as count
FROM parse_ast('
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
', 'duckdb')
GROUP BY super_kind
ORDER BY super_kind;
----
COMPUTATION	1
CONTROL_EFFECTS	1