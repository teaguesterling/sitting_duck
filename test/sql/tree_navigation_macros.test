# name: test/sql/tree_navigation_macros.test
# group: [sql]

# Test tree navigation SQL macros

require sitting_duck

statement ok
LOAD sitting_duck;

# Create a temp table with Python AST for testing
# Note: Leading newline means code starts at line 2
statement ok
CREATE TEMP TABLE test_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        return x
    return inner()
', 'python');

# Find the outer function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer

# Find the inner function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner

# =============================================================================
# Test ast_call_arguments
# =============================================================================

# Create a table with function calls for testing
statement ok
CREATE TEMP TABLE call_test AS
SELECT * FROM parse_ast('foo(a, b, "hello", 42)', 'python');

# Find the call node_id
query II
SELECT node_id, name FROM call_test WHERE type = 'call';
----
2	foo

# Get arguments of the call
query III
SELECT arg_position, arg_name, arg_type FROM ast_call_arguments('call_test', 2);
----
0	a	identifier
1	b	identifier
2	"hello"	string
3	42	integer

# Test with C++ call
statement ok
CREATE TEMP TABLE cpp_call AS
SELECT * FROM parse_ast('loader.RegisterFunction(GetFunc())', 'cpp');

# Get C++ call arguments
query III
SELECT arg_position, arg_name, arg_type
FROM ast_call_arguments('cpp_call', 2);
----
0	GetFunc	call_expression

# =============================================================================
# Test ast_children
# =============================================================================

# Get children of the outer function (node_id=1)
# Should include: def keyword, identifier, parameters, colon, block
query I
SELECT COUNT(*) FROM ast_children('test_ast', 1);
----
5

# Verify child types
query I
SELECT type FROM ast_children('test_ast', 1) ORDER BY node_id;
----
def
identifier
parameters
:
block

# Get children of the module (node_id=0)
query II
SELECT type, name FROM ast_children('test_ast', 0) ORDER BY node_id;
----
function_definition	outer

# =============================================================================
# Test ast_descendants
# =============================================================================

# Get all descendants of inner function (node_id=14)
# The inner function has descendant_count=10
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14);
----
10

# Verify descendants include the return statement
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14) WHERE type = 'return_statement';
----
1

# =============================================================================
# Test ast_ancestors
# =============================================================================

# Get ancestors of the inner function's return statement (node_id=22)
# Ancestor chain: return_statement < block < inner function < block < outer function < module
query I
SELECT type FROM ast_ancestors('test_ast', 22) ORDER BY depth;
----
module
function_definition
block
function_definition
block
return_statement

# Verify we can find the containing function
query II
SELECT type, name FROM ast_ancestors('test_ast', 22)
WHERE type = 'function_definition'
ORDER BY depth
LIMIT 1;
----
function_definition	outer

# =============================================================================
# Test ast_siblings
# =============================================================================

# Get siblings of inner function definition (node_id=14)
# Siblings: expression_statement (x=1), return_statement (return inner())
query I
SELECT COUNT(*) FROM ast_siblings('test_ast', 14);
----
2

# Verify sibling types
query I
SELECT type FROM ast_siblings('test_ast', 14) ORDER BY node_id;
----
expression_statement
return_statement

# =============================================================================
# Test ast_containing_line
# =============================================================================

# Find what contains line 5 (the 'return x' inside inner function)
query I
SELECT type FROM ast_containing_line('test_ast', 5)
WHERE type IN ('function_definition', 'module')
ORDER BY (end_line - start_line);
----
function_definition
function_definition
module

# =============================================================================
# Test ast_in_range
# =============================================================================

# Get all nodes in lines 2-3 (outer function def line + x=1 assignment)
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3);
----
11

# Verify we got the assignment in that range
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3) WHERE type = 'expression_statement';
----
1

# =============================================================================
# Test ast_function_scope
# =============================================================================

# Create a new AST with nested functions for scope testing
statement ok
CREATE TEMP TABLE scope_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        y = 2
        return y
    return inner() + x
', 'python');

# Get outer function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer	38

# Get inner function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner	15

# ast_function_scope should return outer's descendants MINUS inner's contents
# 38 total - 15 inside inner = 23 nodes
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1);
----
23

# Verify: should see outer's return statement but NOT inner's
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
1

# The return statement we see should be outer's (line 7: return inner() + x)
query I
SELECT start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
7

# Verify: should see outer's assignment (x=1) but NOT inner's (y=2)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
1

# The assignment should be x=1 on line 3
query II
SELECT name, start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
x	3

# ast_function_scope on inner should return all of inner's descendants (no nesting)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 14);
----
15

# =============================================================================
# Test ast_class_members
# =============================================================================

# Create a Python class AST for testing
statement ok
CREATE TEMP TABLE py_class AS
SELECT * FROM parse_ast('class MyClass:
    class_var = 1
    def __init__(self, value):
        local_var = 10
        self.value = value
    def method(self):
        temp = 5
        return self.value
', 'python');

# Get the class node_id
query II
SELECT node_id, name FROM py_class WHERE type = 'class_definition';
----
1	MyClass

# Get class members - should have 3: class_var, __init__, method
query I
SELECT COUNT(*) FROM ast_class_members('py_class', 1);
----
3

# Verify member names (should NOT include local_var or temp)
query I
SELECT name FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var
__init__
method

# Verify member types
query II
SELECT name, type FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var	assignment
__init__	function_definition
method	function_definition

# Create a Java class AST for testing
statement ok
CREATE TEMP TABLE java_class AS
SELECT * FROM parse_ast('class MyClass {
    private int x = 1;
    public MyClass(int value) {
        int local = 10;
        this.value = value;
    }
    public int getValue() {
        int temp = 5;
        return this.value;
    }
}', 'java');

# Get the Java class node_id
query II
SELECT node_id, name FROM java_class WHERE type = 'class_declaration';
----
1	MyClass

# Get Java class members - should have 3: x, MyClass (constructor), getValue
query I
SELECT COUNT(*) FROM ast_class_members('java_class', 1);
----
3

# Verify Java member names (should NOT include local or temp)
query I
SELECT name FROM ast_class_members('java_class', 1) ORDER BY node_id;
----
x
MyClass
getValue

# =============================================================================
# Test ast_function_metrics
# =============================================================================

# Create a Python AST with functions of varying complexity
statement ok
CREATE TEMP TABLE metrics_ast AS
SELECT * FROM parse_ast('def simple():
    return 1
def with_loop(n):
    for i in range(n):
        print(i)
    return n
def with_conditional(x):
    if x > 0:
        return 1
    else:
        return -1
def complex_func(x):
    if x > 0:
        for i in range(x):
            if i % 2 == 0:
                print(i)
    else:
        while x < 0:
            x += 1
    return x
', 'python');

# Get metrics for all functions
query IIIIII
SELECT name, lines, return_count, conditionals, loops, cyclomatic
FROM ast_function_metrics('metrics_ast')
ORDER BY name;
----
complex_func	9	1	3	2	6
simple	2	1	0	0	1
with_conditional	5	2	2	0	3
with_loop	4	1	0	1	2

# Verify simple function has cyclomatic complexity of 1
query II
SELECT name, cyclomatic FROM ast_function_metrics('metrics_ast') WHERE name = 'simple';
----
simple	1

# Verify complex function has higher cyclomatic complexity
query II
SELECT name, cyclomatic FROM ast_function_metrics('metrics_ast') WHERE name = 'complex_func';
----
complex_func	6

# Test with nested functions - nested function metrics should be separate
statement ok
CREATE TEMP TABLE nested_metrics AS
SELECT * FROM parse_ast('def outer():
    x = 1
    def inner():
        if True:
            return 1
        return 0
    return inner()
', 'python');

# Both functions should appear with correct metrics
# outer: 1 return, 0 conditionals (inner's if excluded)
# inner: 2 returns, 1 conditional
query IIII
SELECT name, return_count, conditionals, cyclomatic
FROM ast_function_metrics('nested_metrics')
ORDER BY name;
----
inner	2	1	2
outer	1	0	1

# =============================================================================
# Test ast_functions_containing
# =============================================================================

# Create AST with various node types to search for
statement ok
CREATE TEMP TABLE containing_ast AS
SELECT * FROM parse_ast('def has_try():
    try:
        risky()
    except:
        pass
def no_try():
    safe()
def has_eval():
    result = eval("1+1")
    return result
def nested_try():
    def inner():
        try:
            x = 1
        except:
            pass
    inner()
', 'python');

# Find functions with try statements
# Should find has_try and inner (not nested_try - its try is in inner's scope)
query I
SELECT func_name FROM ast_functions_containing('containing_ast', 'try_statement') ORDER BY func_name;
----
has_try
inner

# Find functions with calls named 'eval'
query II
SELECT func_name, match_name
FROM ast_functions_containing('containing_ast', 'call')
WHERE match_name = 'eval';
----
has_eval	eval

# Find all functions with any call
query I
SELECT DISTINCT func_name FROM ast_functions_containing('containing_ast', 'call') ORDER BY func_name;
----
has_eval
has_try
nested_try
no_try

# Verify nested function scope isolation
# nested_try should NOT have try_statement in its scope (it's in inner's scope)
query I
SELECT COUNT(*) FROM ast_functions_containing('containing_ast', 'try_statement')
WHERE func_name = 'nested_try';
----
0

# =============================================================================
# Test ast_nesting_analysis
# =============================================================================

# Create AST with functions of varying nesting depth
statement ok
CREATE TEMP TABLE nesting_ast AS
SELECT * FROM parse_ast('def shallow():
    return 1
def medium():
    if x:
        for i in range(10):
            print(i)
def deep():
    if x:
        if y:
            if z:
                for i in range(10):
                    for j in range(10):
                        if i == j:
                            print(i, j)
', 'python');

# Get nesting analysis for all functions
query III
SELECT name, max_depth, deep_nodes
FROM ast_nesting_analysis('nesting_ast')
ORDER BY name;
----
deep	17	46
medium	9	12
shallow	3	0

# Shallow function should have no deep nodes
query II
SELECT name, deep_nodes FROM ast_nesting_analysis('nesting_ast') WHERE name = 'shallow';
----
shallow	0

# Deep function should have highest max_depth
query II
SELECT name, max_depth FROM ast_nesting_analysis('nesting_ast')
ORDER BY max_depth DESC LIMIT 1;
----
deep	17

# Verify deep_nodes counts nodes with relative depth > 5
# shallow: max_depth=3, so 0 deep nodes
# medium: max_depth=9, some nodes at depth > 5
# deep: max_depth=17, many nodes at depth > 5
query I
SELECT name FROM ast_nesting_analysis('nesting_ast') WHERE deep_nodes = 0;
----
shallow

# =============================================================================
# Test ast_security_audit
# =============================================================================

# Create AST with various security concerns
statement ok
CREATE TEMP TABLE security_ast AS
SELECT * FROM parse_ast('import os
import pickle
def dangerous_eval(user_input):
    result = eval(user_input)
    return result
def run_command(cmd):
    os.system(cmd)
def load_data(filename):
    with open(filename, "rb") as f:
        return pickle.load(f)
def safe_function():
    return 42
', 'python');

# Find all high-risk security issues
query II
SELECT function_name, risk_category
FROM ast_security_audit('security_ast')
WHERE risk_level = 'high'
ORDER BY function_name;
----
dangerous_eval	Code Injection
load_data	Deserialization
run_command	Command Injection

# Verify eval is detected as Code Injection
query III
SELECT function_name, risk_category, matched_pattern
FROM ast_security_audit('security_ast')
WHERE matched_pattern = 'eval';
----
dangerous_eval	Code Injection	eval

# Verify system is detected as Command Injection
query III
SELECT function_name, risk_category, matched_pattern
FROM ast_security_audit('security_ast')
WHERE matched_pattern = 'system';
----
run_command	Command Injection	system

# Verify pickle.load is detected via peek context
query II
SELECT function_name, risk_category
FROM ast_security_audit('security_ast')
WHERE function_name = 'load_data';
----
load_data	Deserialization

# safe_function should not appear in security audit
query I
SELECT COUNT(*)
FROM ast_security_audit('security_ast')
WHERE function_name = 'safe_function';
----
0

# =============================================================================
# Test ast_dead_code
# =============================================================================

# Create an AST with used and unused code
statement ok
CREATE TEMP TABLE dead_code_ast AS
SELECT * FROM parse_ast('def used_func():
    return 1
def unused_func():
    return 2
def main():
    result = used_func()
    return result
class UsedClass:
    pass
class UnusedClass:
    pass
obj = UsedClass()
def __init__(self):
    pass
', 'python');

# Find unused code - should find unused_func and UnusedClass
query II
SELECT name, definition_type FROM ast_dead_code('dead_code_ast') ORDER BY name;
----
UnusedClass	class
unused_func	function

# Verify main is excluded (special method)
query I
SELECT COUNT(*) FROM ast_dead_code('dead_code_ast') WHERE name = 'main';
----
0

# Verify dunder methods are excluded
query I
SELECT COUNT(*) FROM ast_dead_code('dead_code_ast') WHERE name = '__init__';
----
0

# Verify used functions are not marked as dead
query I
SELECT COUNT(*) FROM ast_dead_code('dead_code_ast') WHERE name = 'used_func';
----
0

# Test recursive function is not marked as dead
statement ok
CREATE TEMP TABLE recursive_ast AS
SELECT * FROM parse_ast('def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
', 'python');

# Recursive function references itself, so not dead
query I
SELECT COUNT(*) FROM ast_dead_code('recursive_ast');
----
0

