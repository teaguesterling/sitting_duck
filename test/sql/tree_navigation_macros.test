# name: test/sql/tree_navigation_macros.test
# group: [sql]

# Test tree navigation SQL macros

require sitting_duck

statement ok
LOAD sitting_duck;

# Create a temp table with Python AST for testing
# Note: Leading newline means code starts at line 2
statement ok
CREATE TEMP TABLE test_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        return x
    return inner()
', 'python');

# Find the outer function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer

# Find the inner function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner

# =============================================================================
# Test ast_children
# =============================================================================

# Get children of the outer function (node_id=1)
# Should include: def keyword, identifier, parameters, colon, block
query I
SELECT COUNT(*) FROM ast_children('test_ast', 1);
----
5

# Verify child types
query I
SELECT type FROM ast_children('test_ast', 1) ORDER BY node_id;
----
def
identifier
parameters
:
block

# Get children of the module (node_id=0)
query II
SELECT type, name FROM ast_children('test_ast', 0) ORDER BY node_id;
----
function_definition	outer

# =============================================================================
# Test ast_descendants
# =============================================================================

# Get all descendants of inner function (node_id=14)
# The inner function has descendant_count=10
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14);
----
10

# Verify descendants include the return statement
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14) WHERE type = 'return_statement';
----
1

# =============================================================================
# Test ast_ancestors
# =============================================================================

# Get ancestors of the inner function's return statement (node_id=22)
# Ancestor chain: return_statement < block < inner function < block < outer function < module
query I
SELECT type FROM ast_ancestors('test_ast', 22) ORDER BY depth;
----
module
function_definition
block
function_definition
block
return_statement

# Verify we can find the containing function
query II
SELECT type, name FROM ast_ancestors('test_ast', 22)
WHERE type = 'function_definition'
ORDER BY depth
LIMIT 1;
----
function_definition	outer

# =============================================================================
# Test ast_siblings
# =============================================================================

# Get siblings of inner function definition (node_id=14)
# Siblings: expression_statement (x=1), return_statement (return inner())
query I
SELECT COUNT(*) FROM ast_siblings('test_ast', 14);
----
2

# Verify sibling types
query I
SELECT type FROM ast_siblings('test_ast', 14) ORDER BY node_id;
----
expression_statement
return_statement

# =============================================================================
# Test ast_containing_line
# =============================================================================

# Find what contains line 5 (the 'return x' inside inner function)
query I
SELECT type FROM ast_containing_line('test_ast', 5)
WHERE type IN ('function_definition', 'module')
ORDER BY (end_line - start_line);
----
function_definition
function_definition
module

# =============================================================================
# Test ast_in_range
# =============================================================================

# Get all nodes in lines 2-3 (outer function def line + x=1 assignment)
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3);
----
11

# Verify we got the assignment in that range
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3) WHERE type = 'expression_statement';
----
1

# =============================================================================
# Test ast_function_scope
# =============================================================================

# Create a new AST with nested functions for scope testing
statement ok
CREATE TEMP TABLE scope_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        y = 2
        return y
    return inner() + x
', 'python');

# Get outer function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer	38

# Get inner function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner	15

# ast_function_scope should return outer's descendants MINUS inner's contents
# 38 total - 15 inside inner = 23 nodes
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1);
----
23

# Verify: should see outer's return statement but NOT inner's
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
1

# The return statement we see should be outer's (line 7: return inner() + x)
query I
SELECT start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
7

# Verify: should see outer's assignment (x=1) but NOT inner's (y=2)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
1

# The assignment should be x=1 on line 3
query II
SELECT name, start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
x	3

# ast_function_scope on inner should return all of inner's descendants (no nesting)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 14);
----
15

# =============================================================================
# Test ast_class_members
# =============================================================================

# Create a Python class AST for testing
statement ok
CREATE TEMP TABLE py_class AS
SELECT * FROM parse_ast('class MyClass:
    class_var = 1
    def __init__(self, value):
        local_var = 10
        self.value = value
    def method(self):
        temp = 5
        return self.value
', 'python');

# Get the class node_id
query II
SELECT node_id, name FROM py_class WHERE type = 'class_definition';
----
1	MyClass

# Get class members - should have 3: class_var, __init__, method
query I
SELECT COUNT(*) FROM ast_class_members('py_class', 1);
----
3

# Verify member names (should NOT include local_var or temp)
query I
SELECT name FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var
__init__
method

# Verify member types
query II
SELECT name, type FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var	assignment
__init__	function_definition
method	function_definition

# Create a Java class AST for testing
statement ok
CREATE TEMP TABLE java_class AS
SELECT * FROM parse_ast('class MyClass {
    private int x = 1;
    public MyClass(int value) {
        int local = 10;
        this.value = value;
    }
    public int getValue() {
        int temp = 5;
        return this.value;
    }
}', 'java');

# Get the Java class node_id
query II
SELECT node_id, name FROM java_class WHERE type = 'class_declaration';
----
1	MyClass

# Get Java class members - should have 3: x, MyClass (constructor), getValue
query I
SELECT COUNT(*) FROM ast_class_members('java_class', 1);
----
3

# Verify Java member names (should NOT include local or temp)
query I
SELECT name FROM ast_class_members('java_class', 1) ORDER BY node_id;
----
x
MyClass
getValue

# =============================================================================
# Test ast_function_metrics
# =============================================================================

# Create a Python AST with functions of varying complexity
statement ok
CREATE TEMP TABLE metrics_ast AS
SELECT * FROM parse_ast('def simple():
    return 1
def with_loop(n):
    for i in range(n):
        print(i)
    return n
def with_conditional(x):
    if x > 0:
        return 1
    else:
        return -1
def complex_func(x):
    if x > 0:
        for i in range(x):
            if i % 2 == 0:
                print(i)
    else:
        while x < 0:
            x += 1
    return x
', 'python');

# Get metrics for all functions
query IIIIII
SELECT name, lines, return_count, conditionals, loops, cyclomatic
FROM ast_function_metrics('metrics_ast')
ORDER BY name;
----
complex_func	9	1	3	2	6
simple	2	1	0	0	1
with_conditional	5	2	2	0	3
with_loop	4	1	0	1	2

# Verify simple function has cyclomatic complexity of 1
query II
SELECT name, cyclomatic FROM ast_function_metrics('metrics_ast') WHERE name = 'simple';
----
simple	1

# Verify complex function has higher cyclomatic complexity
query II
SELECT name, cyclomatic FROM ast_function_metrics('metrics_ast') WHERE name = 'complex_func';
----
complex_func	6

# Test with nested functions - nested function metrics should be separate
statement ok
CREATE TEMP TABLE nested_metrics AS
SELECT * FROM parse_ast('def outer():
    x = 1
    def inner():
        if True:
            return 1
        return 0
    return inner()
', 'python');

# Both functions should appear with correct metrics
# outer: 1 return, 0 conditionals (inner's if excluded)
# inner: 2 returns, 1 conditional
query IIII
SELECT name, return_count, conditionals, cyclomatic
FROM ast_function_metrics('nested_metrics')
ORDER BY name;
----
inner	2	1	2
outer	1	0	1

# =============================================================================
# Test ast_functions_containing
# =============================================================================

# Create AST with various node types to search for
statement ok
CREATE TEMP TABLE containing_ast AS
SELECT * FROM parse_ast('def has_try():
    try:
        risky()
    except:
        pass
def no_try():
    safe()
def has_eval():
    result = eval("1+1")
    return result
def nested_try():
    def inner():
        try:
            x = 1
        except:
            pass
    inner()
', 'python');

# Find functions with try statements
# Should find has_try and inner (not nested_try - its try is in inner's scope)
query I
SELECT func_name FROM ast_functions_containing('containing_ast', 'try_statement') ORDER BY func_name;
----
has_try
inner

# Find functions with calls named 'eval'
query II
SELECT func_name, match_name
FROM ast_functions_containing('containing_ast', 'call')
WHERE match_name = 'eval';
----
has_eval	eval

# Find all functions with any call
query I
SELECT DISTINCT func_name FROM ast_functions_containing('containing_ast', 'call') ORDER BY func_name;
----
has_eval
has_try
nested_try
no_try

# Verify nested function scope isolation
# nested_try should NOT have try_statement in its scope (it's in inner's scope)
query I
SELECT COUNT(*) FROM ast_functions_containing('containing_ast', 'try_statement')
WHERE func_name = 'nested_try';
----
0

