# name: test/sql/tree_navigation_macros.test
# group: [sql]

# Test tree navigation SQL macros

require sitting_duck

statement ok
LOAD sitting_duck;

# Create a temp table with Python AST for testing
# Note: Leading newline means code starts at line 2
statement ok
CREATE TEMP TABLE test_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        return x
    return inner()
', 'python');

# Find the outer function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer

# Find the inner function node_id
query II
SELECT node_id, name FROM test_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner

# =============================================================================
# Test ast_children
# =============================================================================

# Get children of the outer function (node_id=1)
# Should include: def keyword, identifier, parameters, colon, block
query I
SELECT COUNT(*) FROM ast_children('test_ast', 1);
----
5

# Verify child types
query I
SELECT type FROM ast_children('test_ast', 1) ORDER BY node_id;
----
def
identifier
parameters
:
block

# Get children of the module (node_id=0)
query II
SELECT type, name FROM ast_children('test_ast', 0) ORDER BY node_id;
----
function_definition	outer

# =============================================================================
# Test ast_descendants
# =============================================================================

# Get all descendants of inner function (node_id=14)
# The inner function has descendant_count=10
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14);
----
10

# Verify descendants include the return statement
query I
SELECT COUNT(*) FROM ast_descendants('test_ast', 14) WHERE type = 'return_statement';
----
1

# =============================================================================
# Test ast_ancestors
# =============================================================================

# Get ancestors of the inner function's return statement (node_id=22)
# Ancestor chain: return_statement < block < inner function < block < outer function < module
query I
SELECT type FROM ast_ancestors('test_ast', 22) ORDER BY depth;
----
module
function_definition
block
function_definition
block
return_statement

# Verify we can find the containing function
query II
SELECT type, name FROM ast_ancestors('test_ast', 22)
WHERE type = 'function_definition'
ORDER BY depth
LIMIT 1;
----
function_definition	outer

# =============================================================================
# Test ast_siblings
# =============================================================================

# Get siblings of inner function definition (node_id=14)
# Siblings: expression_statement (x=1), return_statement (return inner())
query I
SELECT COUNT(*) FROM ast_siblings('test_ast', 14);
----
2

# Verify sibling types
query I
SELECT type FROM ast_siblings('test_ast', 14) ORDER BY node_id;
----
expression_statement
return_statement

# =============================================================================
# Test ast_containing_line
# =============================================================================

# Find what contains line 5 (the 'return x' inside inner function)
query I
SELECT type FROM ast_containing_line('test_ast', 5)
WHERE type IN ('function_definition', 'module')
ORDER BY (end_line - start_line);
----
function_definition
function_definition
module

# =============================================================================
# Test ast_in_range
# =============================================================================

# Get all nodes in lines 2-3 (outer function def line + x=1 assignment)
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3);
----
11

# Verify we got the assignment in that range
query I
SELECT COUNT(*) FROM ast_in_range('test_ast', 2, 3) WHERE type = 'expression_statement';
----
1

# =============================================================================
# Test ast_function_scope
# =============================================================================

# Create a new AST with nested functions for scope testing
statement ok
CREATE TEMP TABLE scope_ast AS
SELECT * FROM parse_ast('
def outer():
    x = 1
    def inner():
        y = 2
        return y
    return inner() + x
', 'python');

# Get outer function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'outer';
----
1	outer	38

# Get inner function info
query III
SELECT node_id, name, descendant_count FROM scope_ast
WHERE type = 'function_definition' AND name = 'inner';
----
14	inner	15

# ast_function_scope should return outer's descendants MINUS inner's contents
# 38 total - 15 inside inner = 23 nodes
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1);
----
23

# Verify: should see outer's return statement but NOT inner's
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
1

# The return statement we see should be outer's (line 7: return inner() + x)
query I
SELECT start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'return_statement';
----
7

# Verify: should see outer's assignment (x=1) but NOT inner's (y=2)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
1

# The assignment should be x=1 on line 3
query II
SELECT name, start_line FROM ast_function_scope('scope_ast', 1) WHERE type = 'assignment';
----
x	3

# ast_function_scope on inner should return all of inner's descendants (no nesting)
query I
SELECT COUNT(*) FROM ast_function_scope('scope_ast', 14);
----
15

# =============================================================================
# Test ast_class_members
# =============================================================================

# Create a Python class AST for testing
statement ok
CREATE TEMP TABLE py_class AS
SELECT * FROM parse_ast('class MyClass:
    class_var = 1
    def __init__(self, value):
        local_var = 10
        self.value = value
    def method(self):
        temp = 5
        return self.value
', 'python');

# Get the class node_id
query II
SELECT node_id, name FROM py_class WHERE type = 'class_definition';
----
1	MyClass

# Get class members - should have 3: class_var, __init__, method
query I
SELECT COUNT(*) FROM ast_class_members('py_class', 1);
----
3

# Verify member names (should NOT include local_var or temp)
query I
SELECT name FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var
__init__
method

# Verify member types
query II
SELECT name, type FROM ast_class_members('py_class', 1) ORDER BY node_id;
----
class_var	assignment
__init__	function_definition
method	function_definition

# Create a Java class AST for testing
statement ok
CREATE TEMP TABLE java_class AS
SELECT * FROM parse_ast('class MyClass {
    private int x = 1;
    public MyClass(int value) {
        int local = 10;
        this.value = value;
    }
    public int getValue() {
        int temp = 5;
        return this.value;
    }
}', 'java');

# Get the Java class node_id
query II
SELECT node_id, name FROM java_class WHERE type = 'class_declaration';
----
1	MyClass

# Get Java class members - should have 3: x, MyClass (constructor), getValue
query I
SELECT COUNT(*) FROM ast_class_members('java_class', 1);
----
3

# Verify Java member names (should NOT include local or temp)
query I
SELECT name FROM ast_class_members('java_class', 1) ORDER BY node_id;
----
x
MyClass
getValue

