// Python node type mappings
// Format: DEF_TYPE(raw_type, semantic_type, name_extraction, native_extraction, flags)

// Function definitions
DEF_TYPE("function_definition", DEFINITION_FUNCTION, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("async_function_definition", DEFINITION_FUNCTION, FIND_IDENTIFIER, ASYNC_FUNCTION, 0)

// Class definitions  
DEF_TYPE("class_definition", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)

// Variable declarations
DEF_TYPE("assignment", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, 0)

// Function calls and expressions
DEF_TYPE("call", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, CUSTOM, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("binary_operator", OPERATOR_ARITHMETIC, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("unary_operator", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("comparison_operator", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("boolean_operator", OPERATOR_LOGICAL, NONE, NONE, 0)

// Identifiers and references
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("attribute", COMPUTATION_ACCESS, NODE_TEXT, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("subscript", COMPUTATION_ACCESS, NONE, NONE, 0)

// Literals - name and value both contain the literal text
DEF_TYPE("string", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("integer", LITERAL_NUMBER, NODE_TEXT, NONE, 0)
DEF_TYPE("float", LITERAL_NUMBER, NODE_TEXT, NONE, 0)
DEF_TYPE("true", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("false", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("none", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

// Control flow
DEF_TYPE("if_statement", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("for_statement", FLOW_LOOP, NONE, NONE, 0)
DEF_TYPE("while_statement", FLOW_LOOP, NONE, NONE, 0)
DEF_TYPE("return_statement", FLOW_JUMP, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("break_statement", FLOW_JUMP, NONE, NONE, 0)
DEF_TYPE("continue_statement", FLOW_JUMP, NONE, NONE, 0)

// Structure
DEF_TYPE("block", ORGANIZATION_BLOCK, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("module", DEFINITION_MODULE, NONE, NONE, 0)
DEF_TYPE("import_statement", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("import_from_statement", EXTERNAL_IMPORT, NONE, NONE, 0)

// Comments
DEF_TYPE("comment", METADATA_COMMENT, NONE, NONE, 0)

// Keywords - now classified by semantic function with IS_KEYWORD flag
DEF_TYPE("def", DEFINITION_FUNCTION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("class", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("if", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("else", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("elif", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("for", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("while", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("return", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("break", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("continue", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("import", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("from", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Punctuation 
DEF_TYPE("(", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE(")", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("[", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("]", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("{", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("}", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE(",", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(":", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(";", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(".", PARSER_PUNCTUATION, NONE, NONE, 0)

// Arithmetic operators
DEF_TYPE("+", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("-", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("*", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("/", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("%", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("**", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("//", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("@", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("&", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("|", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("^", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("~", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("<<", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE(">>", OPERATOR_ARITHMETIC, NONE, NONE, 0)

// Logical operators
DEF_TYPE("and", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("or", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("not", OPERATOR_LOGICAL, NONE, NONE, 0)

// Comparison operators
DEF_TYPE("==", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("!=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("is", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("in", OPERATOR_COMPARISON, NONE, NONE, 0)

// Assignment operators
DEF_TYPE("=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("+=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("-=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("*=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("/=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("%=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("**=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("//=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("@=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("&=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("|=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("^=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("<<=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE(">>=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE(":=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

// Python-specific constructs

// Variadic patterns (PATTERN_COLLECT)
DEF_TYPE("list_splat_pattern", PATTERN_COLLECT, NODE_TEXT, NONE, 0)
DEF_TYPE("dictionary_splat_pattern", PATTERN_COLLECT, NODE_TEXT, NONE, 0)
DEF_TYPE("*", PATTERN_COLLECT, NODE_TEXT, NONE, 0)
DEF_TYPE("**", PATTERN_COLLECT, NODE_TEXT, NONE, 0)

// Scoped references
DEF_TYPE("self", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("super", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("cls", NAME_SCOPED, NODE_TEXT, NONE, 0)

// Decorators and attributes 
DEF_TYPE("@", NAME_ATTRIBUTE, NODE_TEXT, NONE, 0)
DEF_TYPE("decorator", NAME_ATTRIBUTE, FIND_IDENTIFIER, NONE, 0)

// Private/public patterns based on naming convention
// Note: These would need custom logic to detect _name patterns
// For now, we'll handle them as regular identifiers

// Error handling
DEF_TYPE("try_statement", ERROR_TRY, NONE, NONE, 0)
DEF_TYPE("except_clause", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("finally_clause", ERROR_FINALLY, NONE, NONE, 0)
DEF_TYPE("raise_statement", ERROR_THROW, NONE, NONE, 0)
DEF_TYPE("assert_statement", ERROR_THROW, NONE, NONE, 0)

// More keywords
DEF_TYPE("try", ERROR_TRY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("except", ERROR_CATCH, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("finally", ERROR_FINALLY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("raise", ERROR_THROW, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("assert", ERROR_THROW, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("with", FLOW_SYNC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("as", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("lambda", COMPUTATION_CLOSURE, NONE, NONE, ASTNodeFlags::IS_KEYWORD_IF_LEAF)
DEF_TYPE("yield", FLOW_SYNC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("async", FLOW_SYNC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("await", FLOW_SYNC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Missing Python constructs
DEF_TYPE("argument_list", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("string_content", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("string_start", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("string_end", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("expression_statement", EXECUTION_STATEMENT, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("list", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NONE, NONE, 0)
DEF_TYPE("keyword_argument", ORGANIZATION_LIST, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("dotted_name", NAME_QUALIFIED, NODE_TEXT, NONE, 0)
DEF_TYPE("parameters", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("tuple", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NONE, NONE, 0)
DEF_TYPE("type", TYPE_REFERENCE, NODE_TEXT, NONE, 0)
DEF_TYPE("pair", LITERAL_STRUCTURED | SemanticRefinements::Structured::MAPPING, NONE, NONE, 0)
DEF_TYPE("escape_sequence", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("interpolation", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("dictionary", LITERAL_STRUCTURED | SemanticRefinements::Structured::MAPPING, NONE, NONE, 0)

// Advanced Python constructs
DEF_TYPE("typed_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("for_in_clause", FLOW_LOOP, NONE, NONE, 0)
DEF_TYPE("->", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("with_item", COMPUTATION_EXPRESSION, NONE, NONE, 0)
DEF_TYPE("with_statement", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("with_clause", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("list_comprehension", TRANSFORM_QUERY, NONE, NONE, 0)
DEF_TYPE("generic_type", TYPE_GENERIC, NODE_TEXT, NONE, 0)
DEF_TYPE("type_parameter", TYPE_GENERIC, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("parenthesized_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)
DEF_TYPE("pass", EXECUTION_STATEMENT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("pass_statement", EXECUTION_STATEMENT, NONE, NONE, 0)
DEF_TYPE("augmented_assignment", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("decorated_definition", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("not_operator", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("else_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("pattern_list", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("as_pattern_target", PATTERN_DESTRUCTURE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("as_pattern", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("default_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)

// Final Python edge cases
DEF_TYPE("conditional_expression", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("elif_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("typed_default_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("generator_expression", TRANSFORM_QUERY, NONE, NONE, 0)
DEF_TYPE("aliased_import", EXTERNAL_IMPORT, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("slice", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("relative_import", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("import_prefix", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("list_splat", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("not in", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("if_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("expression_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("is not", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("lambda_parameters", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("dictionary_splat", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("escape_interpolation", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("delete_statement", EXECUTION_MUTATION, NONE, NONE, 0)
DEF_TYPE("del", EXECUTION_MUTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("print_statement", EXECUTION_STATEMENT_CALL, NONE, NONE, 0)
DEF_TYPE("print", EXECUTION_STATEMENT_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Final Python edge cases for 100% classification - 489 remaining nodes
DEF_TYPE("tuple_pattern", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("concatenated_string", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("case_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("ellipsis", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("type_conversion", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("global", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("global_statement", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("set", LITERAL_STRUCTURED | SemanticRefinements::Structured::SET, NONE, NONE, 0)
DEF_TYPE("wildcard_import", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("keyword_separator", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("chevron", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("format_specifier", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("list_pattern", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("dictionary_comprehension", TRANSFORM_QUERY, NONE, NONE, 0)
DEF_TYPE("case_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("set_comprehension", TRANSFORM_QUERY, NONE, NONE, 0)
DEF_TYPE("complex_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("attribute_pattern", PATTERN_DESTRUCTURE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("class_pattern", PATTERN_MATCH, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("keyword_pattern", PATTERN_MATCH, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("splat_pattern", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("union_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("value_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("as_clause", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("format_expression", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("conversion", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("interpolation_conversion", LITERAL_STRING, NONE, NONE, 0)

// Absolute final Python edge cases for 100% perfect classification - 79 remaining nodes
DEF_TYPE("case", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("exec", EXECUTION_STATEMENT_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("exec_statement", EXECUTION_STATEMENT_CALL, NONE, NONE, 0)
DEF_TYPE("named_expression", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("nonlocal_statement", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("nonlocal", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("<>", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("line_continuation", PARSER_SYNTAX, NONE, NONE, 0)
DEF_TYPE("match", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("match_statement", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("positional_separator", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("future_import_statement", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("__future__", EXTERNAL_IMPORT, NODE_TEXT, NONE, 0)
DEF_TYPE("_", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)

// ==============================================================================
// Parser-level semantic mappings only (Python comprehensions have distinct syntax)
// ==============================================================================

// List comprehensions and generator expressions - these have distinct syntax
DEF_TYPE("list_comprehension", TRANSFORM_QUERY | SemanticRefinements::Query::SIMPLE, NONE, NONE, 0)
DEF_TYPE("dictionary_comprehension", TRANSFORM_QUERY | SemanticRefinements::Query::SIMPLE, NONE, NONE, 0)
DEF_TYPE("set_comprehension", TRANSFORM_QUERY | SemanticRefinements::Query::SIMPLE, NONE, NONE, 0)
DEF_TYPE("generator_expression", TRANSFORM_QUERY | SemanticRefinements::Query::NESTED, NONE, NONE, 0)

// Note: Built-in function names (map, filter, len, sum, etc.) removed
// since they're just identifiers that could be user-redefined

// Error handling
DEF_TYPE("ERROR", PARSER_SYNTAX, NODE_TEXT, NONE, 0)