// Ruby language node type definitions
// Format: DEF_TYPE(raw_type, semantic_type, name_strategy, value_strategy, flags)

// Module and class definitions
DEF_TYPE("module", DEFINITION_MODULE, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)
DEF_TYPE("class", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)

// Method definitions with refinements
DEF_TYPE("method", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("singleton_method", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("alias", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, NONE, 0)

// Variable and constant definitions with refinements
DEF_TYPE("assignment", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("operator_assignment", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("multiple_assignment", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, NONE, NONE, 0)
DEF_TYPE("constant", DEFINITION_VARIABLE | SemanticRefinements::Variable::IMMUTABLE, NODE_TEXT, NONE, 0)

// Expressions and calls with refinements
DEF_TYPE("call", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, FIND_IDENTIFIER, FUNCTION_CALL, 0)
DEF_TYPE("method_call", COMPUTATION_CALL | SemanticRefinements::Call::METHOD, FIND_IDENTIFIER, FUNCTION_CALL, 0)
DEF_TYPE("chained_call", COMPUTATION_CALL | SemanticRefinements::Call::METHOD, FIND_IDENTIFIER, FUNCTION_CALL, 0)
DEF_TYPE("element_reference", COMPUTATION_ACCESS, NONE, NONE, 0)

// Identifiers and names
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("constant_identifier", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("instance_variable", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("class_variable", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("global_variable", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)

// Literals with refinements - name and value both contain the literal text
DEF_TYPE("integer", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)
DEF_TYPE("float", LITERAL_NUMBER | SemanticRefinements::Number::FLOAT, NODE_TEXT, NONE, 0)
DEF_TYPE("complex", LITERAL_NUMBER | SemanticRefinements::Number::COMPLEX, NODE_TEXT, NONE, 0)
DEF_TYPE("rational", LITERAL_NUMBER | SemanticRefinements::Number::COMPLEX, NODE_TEXT, NONE, 0)
DEF_TYPE("string", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("character", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("symbol", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("simple_symbol", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("regex", LITERAL_STRING | SemanticRefinements::String::REGEX, NODE_TEXT, NONE, 0)
DEF_TYPE("string_array", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NODE_TEXT, NONE, 0)
DEF_TYPE("symbol_array", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NODE_TEXT, NONE, 0)
DEF_TYPE("true", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("false", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("nil", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

// Control flow with refinements
DEF_TYPE("if", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)
DEF_TYPE("unless", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)
DEF_TYPE("case", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)
DEF_TYPE("when", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)
DEF_TYPE("if_modifier", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)
DEF_TYPE("unless_modifier", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)

// Loops with refinements
DEF_TYPE("while", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("until", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("for", FLOW_LOOP | SemanticRefinements::Loop::ITERATOR, NONE, NONE, 0)
DEF_TYPE("while_modifier", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("until_modifier", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)

// Jump statements with refinements
DEF_TYPE("return", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, NONE, 0)
DEF_TYPE("break", FLOW_JUMP | SemanticRefinements::Jump::BREAK, NONE, NONE, 0)
DEF_TYPE("next", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)
DEF_TYPE("redo", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)
DEF_TYPE("retry", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)

// Error handling
DEF_TYPE("begin", ERROR_TRY, NONE, NONE, 0)
DEF_TYPE("rescue", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("ensure", ERROR_FINALLY, NONE, NONE, 0)
DEF_TYPE("raise", ERROR_THROW, NONE, NONE, 0)

// Block and iteration constructs
DEF_TYPE("block", ORGANIZATION_BLOCK, NONE, ARROW_FUNCTION, 0)
DEF_TYPE("do_block", ORGANIZATION_BLOCK, NONE, ARROW_FUNCTION, 0)
DEF_TYPE("lambda", COMPUTATION_CLOSURE, NONE, ARROW_FUNCTION, 0)
DEF_TYPE("proc", COMPUTATION_CLOSURE, NONE, ARROW_FUNCTION, 0)

// Import/export (Ruby uses require/load)
DEF_TYPE("require", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("require_relative", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("load", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Comments
DEF_TYPE("comment", METADATA_COMMENT, NONE, NONE, 0)

// Ruby-specific constructs
DEF_TYPE("yield", FLOW_SYNC, NONE, NONE, 0)
DEF_TYPE("super", COMPUTATION_CALL, NONE, NONE, 0)
DEF_TYPE("self", NAME_SCOPED, NODE_TEXT, NONE, 0)

// Operators
DEF_TYPE("binary", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("unary", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("assignment_operator", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

// ====================================
// MISSING RUBY CONSTRUCTS - Based on ~300 file analysis
// ====================================

// Keywords - now classified by semantic function with IS_KEYWORD flag
DEF_TYPE("def", DEFINITION_FUNCTION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("end", ORGANIZATION_BLOCK, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("class", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("module", DEFINITION_MODULE, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("if", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("unless", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("else", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("elsif", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("case", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("when", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("while", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("until", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("for", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("in", OPERATOR_COMPARISON, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("do", ORGANIZATION_BLOCK, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("begin", ERROR_TRY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("rescue", ERROR_CATCH, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("ensure", ERROR_FINALLY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("raise", ERROR_THROW, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("return", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("break", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("next", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("redo", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("retry", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("yield", FLOW_SYNC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("super", COMPUTATION_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Punctuation and delimiters
DEF_TYPE("\"", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("'", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE(",", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(".", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(":", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(";", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE("(", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE(")", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("[", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("]", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("{", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("}", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("|", PARSER_DELIMITER, NONE, NONE, 0)

// Arithmetic operators
DEF_TYPE("+", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("-", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("*", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("/", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("%", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("**", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("&", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("^", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("~", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("<<", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE(">>", OPERATOR_ARITHMETIC, NONE, NONE, 0)

// Logical operators
DEF_TYPE("&&", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("||", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("!", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("and", OPERATOR_LOGICAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("or", OPERATOR_LOGICAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("not", OPERATOR_LOGICAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

// Comparison operators
DEF_TYPE("==", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("!=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<=>", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("===", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("=~", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("!~", OPERATOR_COMPARISON, NONE, NONE, 0)

// Assignment operators
DEF_TYPE("=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("+=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("-=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("*=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("/=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("%=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("**=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("&=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("|=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("^=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("<<=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE(">>=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("&&=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("||=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

// Ruby-specific constructs
DEF_TYPE("string_content", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("body_statement", EXECUTION_STATEMENT, NONE, NONE, 0)
DEF_TYPE("argument_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("program", DEFINITION_MODULE, NONE, NONE, 0)
DEF_TYPE("method_parameters", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("in_clause", FLOW_LOOP, NONE, NONE, 0)
DEF_TYPE("bare_symbol", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("parameter_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("block_parameters", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("parenthesized_statements", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("then", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("elsif_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("else_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("rescue_clause", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("ensure_clause", ERROR_FINALLY, NONE, NONE, 0)
DEF_TYPE("when_clause", FLOW_CONDITIONAL, NONE, NONE, 0)

// Advanced Ruby constructs
DEF_TYPE("scope_resolution", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("::", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("splat_argument", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("hash_splat_argument", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("keyword_splat", PATTERN_COLLECT, NONE, NONE, 0)
DEF_TYPE("hash", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("array", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("range", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("interpolation", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("escape_sequence", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("heredoc_beginning", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("heredoc_end", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("heredoc_body", LITERAL_STRING, NONE, NONE, 0)

// Method definition variations
DEF_TYPE("singleton_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("alias_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("undef", EXECUTION_STATEMENT, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)

// Module/class constructs
DEF_TYPE("superclass", TYPE_REFERENCE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("include", EXTERNAL_IMPORT, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("extend", EXTERNAL_IMPORT, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("prepend", EXTERNAL_IMPORT, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)

// Access modifiers
DEF_TYPE("private", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("protected", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("public", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD | ASTNodeFlags::IS_PUBLIC)

// Special variables
DEF_TYPE("__FILE__", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("__LINE__", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("__dir__", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("__ENCODING__", NAME_SCOPED, NODE_TEXT, NONE, 0)

// Pattern matching (Ruby 3.0+)
DEF_TYPE("case_match", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("in_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("variable_pattern", PATTERN_DESTRUCTURE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("array_pattern", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("hash_pattern", PATTERN_DESTRUCTURE, NONE, NONE, 0)
DEF_TYPE("rest_pattern", PATTERN_COLLECT, NONE, NONE, 0)

// Metaprogramming
DEF_TYPE("attr_reader", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("attr_writer", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("attr_accessor", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("define_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("define_singleton_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)

// Ruby-specific literals
DEF_TYPE("word_literal", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("symbol_literal", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("regex_literal", LITERAL_STRING, NODE_TEXT, NONE, 0)

// Final Ruby edge cases - remaining unclassified types
DEF_TYPE("keyword_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("hash_key_symbol", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("bare_string", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("%i(", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("%w(", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("encoding", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("optional_parameter", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("block_body", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("file", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("destructured_parameter", PATTERN_DESTRUCTURE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("lambda_parameters", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE(":\"", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("#{", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("delimited_symbol", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("line", NAME_SCOPED, NODE_TEXT, NONE, 0)
DEF_TYPE("->", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("keyword_parameter", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("alternative_pattern", PATTERN_MATCH, NONE, NONE, 0)
DEF_TYPE("hash_splat_nil", PATTERN_COLLECT, NONE, NONE, 0)

// Final Ruby perfection - 3,875 remaining nodes for 100% classification
DEF_TYPE("pair", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("=>", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("exceptions", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("exception_variable", ERROR_CATCH, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("hash_splat_parameter", PATTERN_COLLECT, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("conditional", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("?", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("&.", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("..", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("heredoc_content", LITERAL_STRING, NONE, NONE, 0)
DEF_TYPE("block_argument", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("defined?", COMPUTATION_CALL, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("chained_string", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("block_parameter", ORGANIZATION_LIST, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("splat_parameter", PATTERN_COLLECT, FIND_IDENTIFIER, NONE, 0)

// Absolute Ruby perfection - final 1 node
DEF_TYPE("...", PATTERN_COLLECT, NONE, NONE, 0)

// ==============================================================================
// Parser-level semantic mappings only
// Note: Ruby enumerable method names (map, select, reduce, etc.) are removed
// since they're just identifiers - could be user-defined methods with different semantics
// ==============================================================================

// Error handling
DEF_TYPE("ERROR", PARSER_SYNTAX, NODE_TEXT, NONE, 0)