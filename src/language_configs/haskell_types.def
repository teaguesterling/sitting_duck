// Haskell language node type definitions
// Format: DEF_TYPE(raw_type, semantic_type, name_strategy, value_strategy, flags)
// TODO: Complete after examining tree-sitter parse results

// Program structure
DEF_TYPE("haskell", DEFINITION_MODULE, NONE, NONE, 0x01)
DEF_TYPE("module", DEFINITION_MODULE, FIND_IDENTIFIER, NONE, 0x01)

// Import statements
DEF_TYPE("import", EXTERNAL_IMPORT, FIND_IDENTIFIER, NONE, 0)

// Function definitions
DEF_TYPE("function", DEFINITION_FUNCTION, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0x01)
DEF_TYPE("bind_pattern", DEFINITION_FUNCTION, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0x01)

// Type definitions
DEF_TYPE("data_type", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0x01)
DEF_TYPE("newtype", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0x01)
DEF_TYPE("type_alias", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0x01)
DEF_TYPE("class_declaration", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0x01)
DEF_TYPE("instance_declaration", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0x01)

// Function calls and expressions
DEF_TYPE("apply", COMPUTATION_CALL, FIND_IDENTIFIER, FUNCTION_CALL, 0)
DEF_TYPE("expression", COMPUTATION_CALL, FIND_IDENTIFIER, FUNCTION_CALL, 0)

// Control flow (pattern matching)
DEF_TYPE("case", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("if", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("guard", FLOW_CONDITIONAL, NONE, NONE, 0)

// Lambda expressions
DEF_TYPE("lambda", DEFINITION_FUNCTION, NONE, ARROW_FUNCTION, 0)

// Identifiers and literals
DEF_TYPE("variable", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("constructor", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("qualified_variable", NAME_QUALIFIED, NODE_TEXT, NONE, 0)
DEF_TYPE("qualified_constructor", NAME_QUALIFIED, NODE_TEXT, NONE, 0)
DEF_TYPE("integer", LITERAL_NUMBER, NODE_TEXT, NONE, 0)
DEF_TYPE("float", LITERAL_NUMBER, NODE_TEXT, NONE, 0)
DEF_TYPE("char", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("string", LITERAL_STRING, NODE_TEXT, NONE, 0)

// List and tuple literals
DEF_TYPE("list", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("tuple", LITERAL_STRUCTURED, NONE, NONE, 0)

// Comments
DEF_TYPE("comment", METADATA_COMMENT, NODE_TEXT, NONE, 0x08)

// Error handling
DEF_TYPE("ERROR", PARSER_SYNTAX, NODE_TEXT, NONE, 0)