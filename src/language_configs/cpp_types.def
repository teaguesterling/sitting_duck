/**
 * @file cpp_types.def
 * @brief C++ language node type mappings for AST semantic extraction
 *
 * This file defines the mapping from tree-sitter C++ node types to semantic
 * categories, extraction strategies, and behavioral flags. C++ extends C
 * with object-oriented, generic, and modern language features.
 *
 * @details
 * Each entry uses the DEF_TYPE macro with the following signature:
 * ```cpp
 * DEF_TYPE(raw_type, semantic_type, name_extraction, native_extraction, flags)
 * ```
 *
 * | Parameter | Description |
 * |-----------|-------------|
 * | raw_type | The tree-sitter node type string (e.g., `"class_specifier"`) |
 * | semantic_type | Base semantic category, optionally OR'd with refinement bits |
 * | name_extraction | Strategy enum from `ExtractionStrategy` for extracting node names |
 * | native_extraction | Strategy enum from `NativeExtractionStrategy` for rich context |
 * | flags | Bitwise OR of `ASTNodeFlags` values |
 *
 * ## C++ Language Characteristics
 *
 * - **Multi-paradigm**: OOP, generic, functional, procedural
 * - **Classes**: Full OOP with inheritance, polymorphism, encapsulation
 * - **Templates**: Compile-time generics and metaprogramming
 * - **RAII**: Resource management via constructors/destructors
 * - **References**: Lvalue (`&`) and rvalue (`&&`) references
 * - **Lambdas**: Anonymous functions with captures (C++11)
 * - **Coroutines**: co_await, co_yield, co_return (C++20)
 * - **Namespaces**: Hierarchical scope organization
 * - **Access specifiers**: public, private, protected
 * - **Virtual functions**: Runtime polymorphism with override/final
 * - **Operator overloading**: Custom operator implementations
 * - **Exception handling**: try/catch/throw with RAII cleanup
 *
 * ## Semantic Type Encoding
 *
 * Semantic types use 8-bit encoding:
 * - Bits 7-2: Base category (e.g., `DEFINITION_CLASS = 0x0C`)
 * - Bits 1-0: Refinement within category
 *
 * Example: `DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR`
 *   - Base: 0x04 (function definition)
 *   - Refinement: 0x02 (constructor)
 *   - Combined: 0x06
 *
 * @see semantic_types.hpp for complete semantic type definitions
 * @see node_config.hpp for extraction strategy enums and refinements
 * @see c_types.def for C base definitions
 */

// ============================================================================
// FUNCTION DEFINITIONS
// ============================================================================

/**
 * @defgroup cpp_functions Function Definitions
 * @brief C++ function and method definitions
 *
 * C++ has regular functions, member functions (methods), constructors,
 * destructors, and lambda expressions. Definitions have bodies (IS_EMBODIED),
 * declarations do not (IS_DECLARATION_ONLY).
 * @{
 */

/**
 * @brief Function definition: `ReturnType name(params) { body }`
 * Uses FIND_QUALIFIED_IDENTIFIER for namespace-qualified names
 */
DEF_TYPE("function_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_QUALIFIED_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT)

/**
 * @brief Function declarator (forward declaration): `ReturnType name(params);`
 * No body - declaration only
 */
DEF_TYPE("function_declarator", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_DECLARATION_ONLY)

/**
 * @brief Method definition in class body
 */
DEF_TYPE("method_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Constructor: `ClassName(params) : initializers { body }`
 * Uses CONSTRUCTOR refinement
 */
DEF_TYPE("constructor_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Destructor: `~ClassName() { body }`
 * Uses CONSTRUCTOR refinement (cleanup counterpart)
 */
DEF_TYPE("destructor_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Lambda expression: `[captures](params) { body }`
 * Uses LAMBDA refinement
 */
DEF_TYPE("lambda_expression", DEFINITION_FUNCTION | SemanticRefinements::Function::LAMBDA, FIND_ASSIGNMENT_TARGET, ARROW_FUNCTION, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Template function definition
 */
DEF_TYPE("template_function", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Template method definition
 */
DEF_TYPE("template_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Preprocessor function-like macro
 */
DEF_TYPE("preproc_function_def", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Default method clause: `= default`
 */
DEF_TYPE("default_method_clause", DEFINITION_FUNCTION, NONE, NONE, 0)

/**
 * @brief Delete method clause: `= delete`
 */
DEF_TYPE("delete_method_clause", DEFINITION_FUNCTION, NONE, NONE, 0)

/** @} */ // end cpp_functions

// ============================================================================
// CLASS DEFINITIONS
// ============================================================================

/**
 * @defgroup cpp_classes Class Definitions
 * @brief C++ class, struct, union, and enum types
 *
 * C++ classes support inheritance, access control, and polymorphism.
 * All class-like constructs have bodies (IS_EMBODIED).
 * @{
 */

/**
 * @brief Class definition: `class Name : public Base { members };`
 */
DEF_TYPE("class_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Struct definition: `struct Name { members };`
 * Default public access (vs class default private)
 */
DEF_TYPE("struct_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Union definition: `union Name { members };`
 */
DEF_TYPE("union_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Enum definition: `enum Name { values };` or `enum class Name { values };`
 */
DEF_TYPE("enum_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Type definition (typedef or using)
 */
DEF_TYPE("type_definition", DEFINITION_CLASS, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Base class clause: `: public Base, private Other`
 */
DEF_TYPE("base_class_clause", TYPE_REFERENCE, NONE, NONE, 0)

/** @} */ // end cpp_classes

// ============================================================================
// VARIABLE DECLARATIONS
// ============================================================================

/**
 * @defgroup cpp_variables Variable Declarations
 * @brief Variable, parameter, and field declarations
 * @{
 */

/**
 * @brief Variable declaration: `Type name = value;`
 */
DEF_TYPE("declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT)

/**
 * @brief Function parameter: `Type name` in parameter list
 */
DEF_TYPE("parameter_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT)

/**
 * @brief Optional parameter with default: `Type name = default`
 */
DEF_TYPE("optional_parameter_declaration", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Field declaration in class: `Type name;`
 */
DEF_TYPE("field_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT)

/**
 * @brief Initializing declarator: `name = value` in declaration
 */
DEF_TYPE("init_declarator", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Enumerator: `NAME` or `NAME = value` in enum
 */
DEF_TYPE("enumerator", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Type alias: `using Name = Type;`
 */
DEF_TYPE("alias_declaration", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)

/** @} */ // end cpp_variables

// ============================================================================
// NAMESPACE AND MODULES
// ============================================================================

/**
 * @defgroup cpp_namespaces Namespaces and Modules
 * @brief Code organization constructs
 * @{
 */

/**
 * @brief Namespace definition: `namespace Name { ... }`
 */
DEF_TYPE("namespace_definition", DEFINITION_MODULE, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/**
 * @brief Translation unit: root of compilation unit
 */
DEF_TYPE("translation_unit", DEFINITION_MODULE, NONE, NONE, ASTNodeFlags::IS_CONSTRUCT)

/** @} */ // end cpp_namespaces

// ============================================================================
// FUNCTION CALLS AND EXPRESSIONS
// ============================================================================

/**
 * @defgroup cpp_calls Function Calls and Expressions
 * @brief Call expressions and operators
 * @{
 */

/**
 * @brief Function call: `func(args)`
 */
DEF_TYPE("call_expression", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, FIND_CALL_TARGET, FUNCTION_CALL, 0)

/**
 * @brief Constructor call: `new Type(args)`
 */
DEF_TYPE("new_expression", COMPUTATION_CALL | SemanticRefinements::Call::CONSTRUCTOR, FIND_CALL_TARGET, FUNCTION_CALL, 0)

/**
 * @brief Destructor call: `delete ptr` or `delete[] ptr`
 */
DEF_TYPE("delete_expression", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, FIND_CALL_TARGET, FUNCTION_CALL, 0)

/**
 * @brief Binary expression: `a + b`, `a * b`, etc.
 */
DEF_TYPE("binary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::BINARY, NONE, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Unary expression: `!a`, `-a`, `*ptr`, `&var`
 */
DEF_TYPE("unary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)

/**
 * @brief Assignment expression: `a = b`
 */
DEF_TYPE("assignment_expression", OPERATOR_ASSIGNMENT | SemanticRefinements::Assignment::SIMPLE, NONE, NONE, 0)

/**
 * @brief Update expression: `a++`, `++a`, `a--`, `--a`
 */
DEF_TYPE("update_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)

/**
 * @brief Cast expression: `(Type)expr` or C++ casts
 */
DEF_TYPE("cast_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)

/**
 * @brief Parenthesized expression: `(expr)`
 */
DEF_TYPE("parenthesized_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)

/**
 * @brief Expression statement: expression used as statement
 */
DEF_TYPE("expression_statement", EXECUTION_STATEMENT, NONE, VARIABLE_WITH_TYPE, 0)

/** @} */ // end cpp_calls

// ============================================================================
// MEMBER ACCESS
// ============================================================================

/**
 * @defgroup cpp_access Member Access
 * @brief Property and pointer access expressions
 * @{
 */

/**
 * @brief Field access: `obj.member`
 */
DEF_TYPE("field_expression", COMPUTATION_ACCESS, NONE, NONE, 0)

/**
 * @brief Subscript access: `array[index]`
 */
DEF_TYPE("subscript_expression", COMPUTATION_ACCESS, NONE, NONE, 0)

/**
 * @brief Pointer dereference or address-of
 */
DEF_TYPE("pointer_expression", COMPUTATION_ACCESS, NONE, NONE, 0)

/** @} */ // end cpp_access

// ============================================================================
// IDENTIFIERS AND REFERENCES
// ============================================================================

/**
 * @defgroup cpp_identifiers Identifiers and References
 * @brief Names and qualified names
 * @{
 */

/**
 * @brief Simple identifier: variable or function name
 */
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Field identifier in member access
 */
DEF_TYPE("field_identifier", NAME_IDENTIFIER, NODE_TEXT, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Namespace identifier: `std`, `boost`, etc.
 */
DEF_TYPE("namespace_identifier", NAME_QUALIFIED, NODE_TEXT, NONE, 0)

/**
 * @brief Qualified identifier: `Namespace::Name`
 */
DEF_TYPE("qualified_identifier", NAME_QUALIFIED, NODE_TEXT, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Scoped identifier in scope resolution
 */
DEF_TYPE("scoped_identifier", NAME_SCOPED, NODE_TEXT, NONE, 0)

/**
 * @brief Operator name for overloading: `operator+`
 */
DEF_TYPE("operator_name", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)

/**
 * @brief Destructor name: `~ClassName`
 */
DEF_TYPE("destructor_name", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)

/**
 * @brief this pointer reference
 */
DEF_TYPE("this", NAME_SCOPED, NONE, NONE, 0)

/** @} */ // end cpp_identifiers

// ============================================================================
// TYPES
// ============================================================================

/**
 * @defgroup cpp_types Type System
 * @brief Type specifiers, references, and templates
 * @{
 */

/**
 * @brief Primitive type: int, char, float, double, void, bool
 */
DEF_TYPE("primitive_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)

/**
 * @brief Type identifier: user-defined type name
 */
DEF_TYPE("type_identifier", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)

/**
 * @brief Sized type specifier: `long int`, `unsigned char`, etc.
 */
DEF_TYPE("sized_type_specifier", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)

/**
 * @brief Struct type reference
 */
DEF_TYPE("struct_type", TYPE_COMPOSITE, NONE, NONE, 0)

/**
 * @brief Union type reference
 */
DEF_TYPE("union_type", TYPE_COMPOSITE, NONE, NONE, 0)

/**
 * @brief Pointer type: `Type*`
 */
DEF_TYPE("pointer_type", TYPE_REFERENCE, NONE, NONE, 0)

/**
 * @brief Reference type: `Type&` (lvalue) or `Type&&` (rvalue)
 */
DEF_TYPE("reference_type", TYPE_REFERENCE, NONE, NONE, 0)

/**
 * @brief Template type: `Template<Args>`
 */
DEF_TYPE("template_type", TYPE_GENERIC, NONE, NONE, 0)

/**
 * @brief Auto type inference (C++11)
 */
DEF_TYPE("auto", TYPE_GENERIC, NONE, NONE, 0)

/**
 * @brief Type descriptor in expressions
 */
DEF_TYPE("type_descriptor", TYPE_COMPOSITE, NONE, NONE, 0)

/**
 * @brief Reference declarator: `&name` or `&&name`
 */
DEF_TYPE("reference_declarator", TYPE_REFERENCE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Pointer declarator: `*name`
 */
DEF_TYPE("pointer_declarator", TYPE_COMPOSITE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Array declarator: `name[size]`
 */
DEF_TYPE("array_declarator", TYPE_COMPOSITE, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Abstract pointer declarator (no name)
 */
DEF_TYPE("abstract_pointer_declarator", TYPE_REFERENCE, NONE, NONE, 0)

/**
 * @brief Abstract reference declarator (no name)
 */
DEF_TYPE("abstract_reference_declarator", TYPE_REFERENCE, NONE, NONE, 0)

/**
 * @brief Abstract function declarator (no name)
 */
DEF_TYPE("abstract_function_declarator", TYPE_COMPOSITE, NONE, NONE, 0)

/**
 * @brief Placeholder type specifier: `decltype(auto)`
 */
DEF_TYPE("placeholder_type_specifier", TYPE_GENERIC, NONE, NONE, 0)

/**
 * @brief Trailing return type: `-> Type`
 */
DEF_TYPE("trailing_return_type", TYPE_REFERENCE, NONE, NONE, 0)

/**
 * @brief Type parameter declaration in template
 */
DEF_TYPE("type_parameter_declaration", TYPE_GENERIC, FIND_IDENTIFIER, NONE, 0)

/** @} */ // end cpp_types

// ============================================================================
// LITERALS
// ============================================================================

/**
 * @defgroup cpp_literals Literals
 * @brief String, number, and structured literals
 * @{
 */

/**
 * @brief String literal: `"hello"`
 */
DEF_TYPE("string_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)

/**
 * @brief Raw string literal: `R"(content)"`
 */
DEF_TYPE("raw_string_literal", LITERAL_STRING | SemanticRefinements::String::RAW, NODE_TEXT, NONE, 0)

/**
 * @brief Character literal: `'a'`
 */
DEF_TYPE("char_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)

/**
 * @brief Number literal: 42, 3.14, 0xFF
 */
DEF_TYPE("number_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)

/**
 * @brief Boolean true
 */
DEF_TYPE("true", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/**
 * @brief Boolean false
 */
DEF_TYPE("false", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/**
 * @brief Null pointer: nullptr
 */
DEF_TYPE("nullptr", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/**
 * @brief Null pointer (C-style)
 */
DEF_TYPE("null", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/**
 * @brief Initializer list: `{ values }`
 */
DEF_TYPE("initializer_list", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NONE, NONE, 0)

/**
 * @brief Compound literal expression
 */
DEF_TYPE("compound_literal_expression", LITERAL_STRUCTURED, NONE, NONE, 0)

/**
 * @brief String content (inside quotes)
 */
DEF_TYPE("string_content", LITERAL_STRING, NODE_TEXT, NONE, 0)

/**
 * @brief Escape sequence: `\n`, `\t`, etc.
 */
DEF_TYPE("escape_sequence", LITERAL_STRING, NODE_TEXT, NONE, 0)

/**
 * @brief Character content
 */
DEF_TYPE("character", LITERAL_STRING, NODE_TEXT, NONE, 0)

/**
 * @brief Concatenated string literals
 */
DEF_TYPE("concatenated_string", LITERAL_STRING, NODE_TEXT, NONE, 0)

/**
 * @brief Raw string delimiter
 */
DEF_TYPE("raw_string_delimiter", LITERAL_STRING, NODE_TEXT, NONE, 0)

/**
 * @brief Raw string content
 */
DEF_TYPE("raw_string_content", LITERAL_STRING, NODE_TEXT, NONE, 0)

/** @} */ // end cpp_literals

// ============================================================================
// CONTROL FLOW
// ============================================================================

/**
 * @defgroup cpp_control Control Flow
 * @brief Conditionals, loops, and jumps
 * @{
 */

/**
 * @brief If statement: `if (cond) stmt`
 */
DEF_TYPE("if_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)

/**
 * @brief Else clause in if statement
 */
DEF_TYPE("else_clause", FLOW_CONDITIONAL, NONE, NONE, 0)

/**
 * @brief Switch statement: `switch (expr) { cases }`
 */
DEF_TYPE("switch_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)

/**
 * @brief Case statement: `case value:`
 */
DEF_TYPE("case_statement", FLOW_CONDITIONAL, NONE, NONE, 0)

/**
 * @brief Conditional/ternary expression: `cond ? then : else`
 */
DEF_TYPE("conditional_expression", FLOW_CONDITIONAL | SemanticRefinements::Conditional::TERNARY, NONE, NONE, 0)

/**
 * @brief Condition clause in control statements
 */
DEF_TYPE("condition_clause", FLOW_CONDITIONAL, NONE, NONE, 0)

/**
 * @brief C-style for loop: `for (init; cond; update)`
 */
DEF_TYPE("for_statement", FLOW_LOOP | SemanticRefinements::Loop::COUNTER, NONE, NONE, 0)

/**
 * @brief Range-based for loop (C++11): `for (auto x : container)`
 */
DEF_TYPE("for_range_loop", FLOW_LOOP | SemanticRefinements::Loop::ITERATOR, NONE, NONE, 0)

/**
 * @brief While loop: `while (cond) stmt`
 */
DEF_TYPE("while_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)

/**
 * @brief Do-while loop: `do stmt while (cond);`
 */
DEF_TYPE("do_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)

/**
 * @brief Return statement: `return expr;`
 */
DEF_TYPE("return_statement", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Break statement: `break;`
 */
DEF_TYPE("break_statement", FLOW_JUMP | SemanticRefinements::Jump::BREAK, NONE, NONE, 0)

/**
 * @brief Continue statement: `continue;`
 */
DEF_TYPE("continue_statement", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)

/**
 * @brief Goto statement: `goto label;`
 */
DEF_TYPE("goto_statement", FLOW_JUMP | SemanticRefinements::Jump::GOTO, NONE, NONE, 0)

/** @} */ // end cpp_control

// ============================================================================
// COROUTINES (C++20)
// ============================================================================

/**
 * @defgroup cpp_coroutines Coroutines (C++20)
 * @brief Coroutine expressions and statements
 * @{
 */

/**
 * @brief co_await expression: `co_await awaitable`
 */
DEF_TYPE("co_await_expression", FLOW_SYNC, NONE, NONE, 0)

/**
 * @brief co_yield expression: `co_yield value`
 */
DEF_TYPE("co_yield_expression", FLOW_SYNC, NONE, NONE, 0)

/**
 * @brief co_return statement: `co_return value;`
 */
DEF_TYPE("co_return_statement", FLOW_SYNC, NONE, NONE, 0)

/** @} */ // end cpp_coroutines

// ============================================================================
// EXCEPTION HANDLING
// ============================================================================

/**
 * @defgroup cpp_exceptions Exception Handling
 * @brief try/catch/throw statements
 * @{
 */

/**
 * @brief Try block: `try { ... }`
 */
DEF_TYPE("try_statement", ERROR_TRY, NONE, NONE, 0)

/**
 * @brief Catch clause: `catch (Type e) { ... }`
 */
DEF_TYPE("catch_clause", ERROR_CATCH, NONE, NONE, 0)

/**
 * @brief Throw statement: `throw exception;`
 */
DEF_TYPE("throw_statement", ERROR_THROW, NONE, NONE, 0)

/** @} */ // end cpp_exceptions

// ============================================================================
// LAMBDA EXPRESSIONS
// ============================================================================

/**
 * @defgroup cpp_lambdas Lambda Expressions
 * @brief Lambda-specific constructs
 * @{
 */

/**
 * @brief Lambda capture specifier: `[captures]`
 */
DEF_TYPE("lambda_capture_specifier", COMPUTATION_CLOSURE, NONE, NONE, 0)

/**
 * @brief Lambda declarator: `(params) -> Type`
 */
DEF_TYPE("lambda_declarator", COMPUTATION_CLOSURE, NONE, NONE, 0)

/**
 * @brief Lambda default capture: `[=]` or `[&]`
 */
DEF_TYPE("lambda_default_capture", COMPUTATION_CLOSURE, NONE, NONE, 0)

/** @} */ // end cpp_lambdas

// ============================================================================
// TEMPLATES
// ============================================================================

/**
 * @defgroup cpp_templates Templates
 * @brief Generic programming constructs
 * @{
 */

/**
 * @brief Template declaration: `template<typename T>`
 */
DEF_TYPE("template_declaration", PATTERN_TEMPLATE, NONE, NONE, 0)

/** @} */ // end cpp_templates

// ============================================================================
// STRUCTURE AND ORGANIZATION
// ============================================================================

/**
 * @defgroup cpp_structure Structure and Organization
 * @brief Blocks and lists
 * @{
 */

/**
 * @brief Compound statement (block): `{ statements }`
 */
DEF_TYPE("compound_statement", ORGANIZATION_BLOCK, NONE, VARIABLE_WITH_TYPE, 0)

/**
 * @brief Function parameter list
 */
DEF_TYPE("parameter_list", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)

/**
 * @brief Function argument list
 */
DEF_TYPE("argument_list", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)

/**
 * @brief Template parameter list
 */
DEF_TYPE("template_parameter_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Template argument list: `<int, string>`
 */
DEF_TYPE("template_argument_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Subscript argument list
 */
DEF_TYPE("subscript_argument_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Declaration list
 */
DEF_TYPE("declaration_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Field declaration list in class
 */
DEF_TYPE("field_declaration_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Enumerator list in enum
 */
DEF_TYPE("enumerator_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Field initializer list in constructor
 */
DEF_TYPE("field_initializer_list", ORGANIZATION_LIST, NONE, NONE, 0)

/**
 * @brief Field initializer: `member(value)`
 */
DEF_TYPE("field_initializer", LITERAL_STRUCTURED, FIND_IDENTIFIER, NONE, 0)

/**
 * @brief Preprocessor params
 */
DEF_TYPE("preproc_params", ORGANIZATION_LIST, NONE, NONE, 0)

/** @} */ // end cpp_structure

// ============================================================================
// IMPORTS AND USING
// ============================================================================

/**
 * @defgroup cpp_imports Imports and Using
 * @brief Include directives and using declarations
 * @{
 */

/**
 * @brief #include directive
 */
DEF_TYPE("preproc_include", EXTERNAL_IMPORT, NONE, NONE, 0)

/**
 * @brief Using declaration: `using namespace std;`
 */
DEF_TYPE("using_declaration", EXTERNAL_IMPORT, NONE, NONE, 0)

/**
 * @brief System library string: `<header>`
 */
DEF_TYPE("system_lib_string", EXTERNAL_IMPORT, NODE_TEXT, NONE, 0)

/** @} */ // end cpp_imports

// ============================================================================
// PREPROCESSOR
// ============================================================================

/**
 * @defgroup cpp_preprocessor Preprocessor Directives
 * @brief Preprocessor and metadata
 * @{
 */

/**
 * @brief Object-like macro definition
 */
DEF_TYPE("preproc_def", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief #ifdef directive
 */
DEF_TYPE("preproc_ifdef", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief #ifndef directive
 */
DEF_TYPE("preproc_ifndef", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief #if directive
 */
DEF_TYPE("preproc_if", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief #else directive
 */
DEF_TYPE("preproc_else", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief Preprocessor macro call
 */
DEF_TYPE("preproc_call", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief Generic preprocessor directive
 */
DEF_TYPE("preproc_directive", METADATA_DIRECTIVE, NONE, NONE, 0)

/**
 * @brief Preprocessor argument
 */
DEF_TYPE("preproc_arg", METADATA_DIRECTIVE, NONE, NONE, 0)

/// @brief Comment: line or block style
DEF_TYPE("comment", METADATA_COMMENT, NONE, NONE, 0)

/** @} */ // end cpp_preprocessor

// ============================================================================
// PUNCTUATION
// ============================================================================

/**
 * @defgroup cpp_punctuation Punctuation
 * @brief Syntactic punctuation tokens
 * @{
 */

/** @brief Comma */
DEF_TYPE(",", PARSER_PUNCTUATION, NONE, NONE, 0)

/** @brief Semicolon */
DEF_TYPE(";", PARSER_PUNCTUATION, NONE, NONE, 0)

/** @brief Dot */
DEF_TYPE(".", PARSER_PUNCTUATION, NONE, NONE, 0)

/** @brief Colon */
DEF_TYPE(":", PARSER_PUNCTUATION, NONE, NONE, 0)

/** @brief Opening parenthesis */
DEF_TYPE("(", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Closing parenthesis */
DEF_TYPE(")", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Opening bracket */
DEF_TYPE("[", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Closing bracket */
DEF_TYPE("]", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Opening brace */
DEF_TYPE("{", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Closing brace */
DEF_TYPE("}", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Double quote */
DEF_TYPE("\"", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Single quote */
DEF_TYPE("'", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Ternary question mark */
DEF_TYPE("?", FLOW_CONDITIONAL, NONE, NONE, 0)

/** @brief Raw string prefix */
DEF_TYPE("R\"", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Empty parentheses */
DEF_TYPE("()", PARSER_DELIMITER, NONE, NONE, 0)

/** @brief Newline (preprocessor) */
DEF_TYPE("\n", PARSER_DELIMITER, NONE, NONE, 0)

/** @} */ // end cpp_punctuation

// ============================================================================
// ASSIGNMENT OPERATORS
// ============================================================================

/**
 * @defgroup cpp_assignment Assignment Operators
 * @brief Simple and compound assignment
 * @{
 */

/** @brief Simple assignment */
DEF_TYPE("=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Add and assign */
DEF_TYPE("+=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Subtract and assign */
DEF_TYPE("-=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Multiply and assign */
DEF_TYPE("*=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Divide and assign */
DEF_TYPE("/=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Modulo and assign */
DEF_TYPE("%=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Bitwise AND and assign */
DEF_TYPE("&=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Bitwise OR and assign */
DEF_TYPE("|=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Bitwise XOR and assign */
DEF_TYPE("^=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Left shift and assign */
DEF_TYPE("<<=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @brief Right shift and assign */
DEF_TYPE(">>=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

/** @} */ // end cpp_assignment

// ============================================================================
// COMPARISON OPERATORS
// ============================================================================

/**
 * @defgroup cpp_comparison Comparison Operators
 * @brief Equality and relational operators
 * @{
 */

/** @brief Equality */
DEF_TYPE("==", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @brief Inequality */
DEF_TYPE("!=", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @brief Less than */
DEF_TYPE("<", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @brief Greater than */
DEF_TYPE(">", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @brief Less than or equal */
DEF_TYPE("<=", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @brief Greater than or equal */
DEF_TYPE(">=", OPERATOR_COMPARISON, NONE, NONE, 0)

/** @} */ // end cpp_comparison

// ============================================================================
// ARITHMETIC OPERATORS
// ============================================================================

/**
 * @defgroup cpp_arithmetic Arithmetic Operators
 * @brief Mathematical and bitwise operators
 * @{
 */

/** @brief Addition */
DEF_TYPE("+", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Subtraction */
DEF_TYPE("-", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Multiplication */
DEF_TYPE("*", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Division */
DEF_TYPE("/", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Modulo */
DEF_TYPE("%", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Bitwise AND */
DEF_TYPE("&", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Bitwise OR */
DEF_TYPE("|", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Bitwise XOR */
DEF_TYPE("^", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Bitwise NOT */
DEF_TYPE("~", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Left shift */
DEF_TYPE("<<", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Right shift */
DEF_TYPE(">>", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Increment */
DEF_TYPE("++", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @brief Decrement */
DEF_TYPE("--", OPERATOR_ARITHMETIC, NONE, NONE, 0)

/** @} */ // end cpp_arithmetic

// ============================================================================
// LOGICAL OPERATORS
// ============================================================================

/**
 * @defgroup cpp_logical Logical Operators
 * @brief Boolean operators
 * @{
 */

/** @brief Logical AND */
DEF_TYPE("&&", OPERATOR_LOGICAL, NONE, NONE, 0)

/** @brief Logical OR */
DEF_TYPE("||", OPERATOR_LOGICAL, NONE, NONE, 0)

/** @brief Logical NOT */
DEF_TYPE("!", OPERATOR_LOGICAL, NONE, NONE, 0)

/** @} */ // end cpp_logical

// ============================================================================
// MEMBER ACCESS OPERATORS
// ============================================================================

/**
 * @defgroup cpp_member_access Member Access Operators
 * @brief Pointer and scope operators
 * @{
 */

/** @brief Pointer member access: `ptr->member` */
DEF_TYPE("->", COMPUTATION_ACCESS, NONE, NONE, 0)

/** @brief Scope resolution: `Namespace::Name` */
DEF_TYPE("::", COMPUTATION_ACCESS, NONE, NONE, 0)

/** @} */ // end cpp_member_access

// ============================================================================
// KEYWORDS
// ============================================================================

/**
 * @defgroup cpp_keywords Keywords
 * @brief C++ reserved words
 * @{
 */

/** @brief if keyword */
DEF_TYPE("if", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief else keyword */
DEF_TYPE("else", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief while keyword */
DEF_TYPE("while", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief for keyword */
DEF_TYPE("for", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief do keyword */
DEF_TYPE("do", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief switch keyword */
DEF_TYPE("switch", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief case keyword */
DEF_TYPE("case", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief default keyword */
DEF_TYPE("default", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief break keyword */
DEF_TYPE("break", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief continue keyword */
DEF_TYPE("continue", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief return keyword */
DEF_TYPE("return", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief goto keyword */
DEF_TYPE("goto", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief try keyword */
DEF_TYPE("try", ERROR_TRY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief catch keyword */
DEF_TYPE("catch", ERROR_CATCH, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief throw keyword */
DEF_TYPE("throw", ERROR_THROW, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief const qualifier */
DEF_TYPE("const", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief static specifier */
DEF_TYPE("static", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief extern specifier */
DEF_TYPE("extern", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief inline specifier */
DEF_TYPE("inline", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief virtual specifier */
DEF_TYPE("virtual", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief override specifier */
DEF_TYPE("override", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief final specifier */
DEF_TYPE("final", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief public access specifier */
DEF_TYPE("public", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief private access specifier */
DEF_TYPE("private", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief protected access specifier */
DEF_TYPE("protected", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief class keyword */
DEF_TYPE("class", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief struct keyword */
DEF_TYPE("struct", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief union keyword */
DEF_TYPE("union", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief enum keyword */
DEF_TYPE("enum", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief namespace keyword */
DEF_TYPE("namespace", DEFINITION_MODULE, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief using keyword */
DEF_TYPE("using", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief typedef keyword */
DEF_TYPE("typedef", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief typename keyword */
DEF_TYPE("typename", TYPE_GENERIC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief template keyword */
DEF_TYPE("template", PATTERN_TEMPLATE, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief sizeof operator */
DEF_TYPE("sizeof", OPERATOR_ARITHMETIC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief new operator */
DEF_TYPE("new", COMPUTATION_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief delete operator */
DEF_TYPE("delete", COMPUTATION_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief constexpr specifier (C++11) */
DEF_TYPE("constexpr", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief noexcept specifier */
DEF_TYPE("noexcept", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief explicit specifier */
DEF_TYPE("explicit", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief mutable specifier */
DEF_TYPE("mutable", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @brief operator keyword (for overloading) */
DEF_TYPE("operator", DEFINITION_FUNCTION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)

/** @} */ // end cpp_keywords

// ============================================================================
// METADATA AND SPECIFIERS
// ============================================================================

/**
 * @defgroup cpp_specifiers Metadata and Specifiers
 * @brief Type qualifiers and specifiers
 * @{
 */

/**
 * @brief Virtual specifier in class
 */
DEF_TYPE("virtual_specifier", METADATA_ANNOTATION, NONE, NONE, 0)

/**
 * @brief Access specifier block: `public:`, `private:`, etc.
 */
DEF_TYPE("access_specifier", METADATA_ANNOTATION, NONE, NONE, 0)

/**
 * @brief Type qualifier: const, volatile
 */
DEF_TYPE("type_qualifier", METADATA_ANNOTATION, NONE, NONE, 0)

/**
 * @brief Storage class specifier: static, extern, etc.
 */
DEF_TYPE("storage_class_specifier", METADATA_ANNOTATION, NONE, NONE, 0)

/**
 * @brief Explicit function specifier
 */
DEF_TYPE("explicit_function_specifier", METADATA_ANNOTATION, NONE, NONE, 0)

/**
 * @brief Linkage specification: `extern "C"`
 */
DEF_TYPE("linkage_specification", METADATA_ANNOTATION, NONE, NONE, 0)

/** @} */ // end cpp_specifiers

// ============================================================================
// PREPROCESSOR DIRECTIVE TOKENS
// ============================================================================

/**
 * @defgroup cpp_preproc_tokens Preprocessor Directive Tokens
 * @brief Preprocessor directive keywords
 * @{
 */

/** @brief #include directive */
DEF_TYPE("#include", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #define directive */
DEF_TYPE("#define", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #ifdef directive */
DEF_TYPE("#ifdef", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #ifndef directive */
DEF_TYPE("#ifndef", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #if directive */
DEF_TYPE("#if", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #else directive */
DEF_TYPE("#else", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #elif directive */
DEF_TYPE("#elif", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #endif directive */
DEF_TYPE("#endif", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #undef directive */
DEF_TYPE("#undef", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @brief #pragma directive */
DEF_TYPE("#pragma", METADATA_DIRECTIVE, NONE, NONE, 0)

/** @} */ // end cpp_preproc_tokens

// ============================================================================
// PARSER ERRORS
// ============================================================================

/**
 * @defgroup cpp_parser_errors Parser Errors
 * @brief Error nodes from parsing
 * @{
 */

/** @brief Parse error node */
DEF_TYPE("ERROR", PARSER_SYNTAX, NONE, NONE, 0)

/** @} */ // end cpp_parser_errors

// ============================================================================
// Note: STL algorithm names (transform, sort, find, etc.) are not included
// since they're just identifiers - could be user-defined functions with
// different semantics. Only parser-level semantic mappings are defined.
// ============================================================================
