/**
 * @file java_types.def
 * @brief Java language node type mappings for AST semantic extraction
 *
 * @details This file defines how tree-sitter Java AST nodes are mapped to
 * universal semantic types, along with strategies for extracting names and
 * native context from the parse tree.
 *
 * ## DEF_TYPE Macro Format
 *
 * ```cpp
 * DEF_TYPE(raw_type, semantic_type, name_extraction, native_extraction, flags)
 * ```
 *
 * @param raw_type The tree-sitter node type string (e.g., "class_declaration")
 * @param semantic_type Universal semantic classification with optional refinement bits
 * @param name_extraction Strategy for extracting the node's name (see ExtractionStrategy)
 * @param native_extraction Strategy for rich context extraction (see NativeExtractionStrategy)
 * @param flags Behavioral flags (e.g., IS_KEYWORD, IS_SYNTAX_ONLY)
 *
 * ## Semantic Type Encoding
 *
 * Semantic types are 8-bit values where:
 * - Bits 7-2: Base semantic category (e.g., DEFINITION_FUNCTION = 0x04)
 * - Bits 1-0: Refinement within category (e.g., Function::LAMBDA = 0x01)
 *
 * Combined using bitwise OR:
 * ```cpp
 * DEFINITION_FUNCTION | SemanticRefinements::Function::LAMBDA  // = 0x05
 * ```
 *
 * ## Java Language Characteristics
 *
 * Java has several unique features that affect AST mapping:
 *
 * - **Class-based OOP**: Everything exists within classes; no standalone functions
 * - **Package system**: Hierarchical namespace via packages
 * - **Access modifiers**: `public`, `private`, `protected`, package-private (default)
 * - **Static members**: Class-level methods and fields
 * - **Final keyword**: Immutable variables, prevent method override, sealed classes
 * - **Constructors**: Special methods for object initialization (CONSTRUCTOR refinement)
 * - **Initializer blocks**: Static and instance initialization blocks
 * - **Interfaces**: Abstract types, can have default methods (Java 8+)
 * - **Enums**: Type-safe enumerations with associated behavior
 * - **Annotations**: Metadata via `@Annotation` syntax
 * - **Generics**: Type parameters on classes and methods
 * - **Lambda expressions**: Functional interfaces (Java 8+)
 * - **Method references**: `::` operator for method handles
 * - **Records**: Immutable data classes (Java 16+)
 * - **Checked exceptions**: Exception handling is part of method signatures
 * - **Enhanced for**: Iterator-based for-each loops
 * - **Switch expressions**: Pattern matching in switch (Java 14+)
 *
 * @see node_config.hpp for ExtractionStrategy and NativeExtractionStrategy definitions
 * @see semantic_types.hpp for full semantic type enumeration
 */

// =============================================================================
// COMPILATION UNIT AND PACKAGES
// =============================================================================

/**
 * @defgroup java_packages Packages and Imports
 * @brief Package declarations and import statements
 *
 * Java organizes code into packages. The `program` node represents the entire
 * compilation unit (source file). Import statements bring in classes from
 * other packages.
 * @{
 */
DEF_TYPE("program", DEFINITION_MODULE, NONE, NONE, 0)
DEF_TYPE("package_declaration", DEFINITION_MODULE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("import_declaration", EXTERNAL_IMPORT | SemanticRefinements::Import::MODULE, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// CLASS AND TYPE DEFINITIONS
// =============================================================================

/**
 * @defgroup java_classes Class and Type Definitions
 * @brief Classes, interfaces, enums, annotations, and records
 *
 * Java's type system includes:
 * - `class`: Regular classes (REGULAR refinement)
 * - `interface`: Abstract types (ABSTRACT refinement)
 * - `enum`: Type-safe enumerations (ENUM refinement)
 * - `annotation_type`: Custom annotation definitions (ABSTRACT refinement)
 * - `record`: Immutable data carriers (Java 16+)
 *
 * All Java type definitions have bodies and are marked with IS_EMBODIED.
 * @{
 */
DEF_TYPE("class_declaration", DEFINITION_CLASS | SemanticRefinements::Class::REGULAR, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("interface_declaration", DEFINITION_CLASS | SemanticRefinements::Class::ABSTRACT, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("enum_declaration", DEFINITION_CLASS | SemanticRefinements::Class::ENUM, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("annotation_type_declaration", DEFINITION_CLASS | SemanticRefinements::Class::ABSTRACT, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("record_declaration", DEFINITION_CLASS | SemanticRefinements::Class::REGULAR, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
/** @} */

// =============================================================================
// METHOD AND CONSTRUCTOR DEFINITIONS
// =============================================================================

/**
 * @defgroup java_methods Method and Constructor Definitions
 * @brief Methods, constructors, and initializer blocks
 *
 * Java methods are always inside classes. Constructors are special methods
 * that initialize objects and get the CONSTRUCTOR refinement.
 *
 * Initializer blocks:
 * - `static_initializer`: Runs once when class is loaded
 * - `instance_initializer`: Runs each time an object is created
 *
 * Lambda expressions (Java 8+) are anonymous functions implementing
 * functional interfaces.
 * @{
 */
DEF_TYPE("method_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("constructor_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, CONSTRUCTOR_DEFINITION, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("static_initializer", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, NONE, NONE, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("instance_initializer", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, NONE, NONE, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)
DEF_TYPE("lambda_expression", DEFINITION_FUNCTION | SemanticRefinements::Function::LAMBDA, FIND_ASSIGNMENT_TARGET, ARROW_FUNCTION, ASTNodeFlags::IS_EMBODIED)
/** @} */

// =============================================================================
// FIELD AND VARIABLE DECLARATIONS
// =============================================================================

/**
 * @defgroup java_variables Field and Variable Declarations
 * @brief Fields, local variables, and parameters
 *
 * Java variables are mutable by default. The `final` modifier makes them
 * immutable, but this is handled via modifier nodes rather than refinements.
 *
 * Variable types:
 * - `field_declaration`: Class-level fields (FIELD refinement)
 * - `local_variable_declaration`: Method-local variables (MUTABLE refinement)
 * - `formal_parameter`: Method parameters (PARAMETER refinement)
 * - `enum_constant`: Enum values (FIELD refinement)
 * @{
 */
DEF_TYPE("field_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("local_variable_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("variable_declarator", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("formal_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("spread_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("catch_formal_parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("enum_constant", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, NONE, 0)
/** @} */

// =============================================================================
// METHOD CALLS AND ACCESS
// =============================================================================

/**
 * @defgroup java_calls Method Calls and Access
 * @brief Method invocations, object creation, and field access
 *
 * Java call expressions:
 * - `method_invocation`: Calling methods on objects (METHOD refinement)
 * - `object_creation_expression`: `new` keyword (CONSTRUCTOR refinement)
 * - `method_reference`: `Class::method` syntax (Java 8+)
 *
 * Field and array access are separate node types.
 * @{
 */
DEF_TYPE("method_invocation", COMPUTATION_CALL | SemanticRefinements::Call::METHOD, FIND_CALL_TARGET, FUNCTION_CALL, 0)
DEF_TYPE("object_creation_expression", COMPUTATION_CALL | SemanticRefinements::Call::CONSTRUCTOR, FIND_CALL_TARGET, FUNCTION_CALL, 0)
DEF_TYPE("method_reference", COMPUTATION_ACCESS, NODE_TEXT, NONE, 0)
DEF_TYPE("field_access", COMPUTATION_ACCESS, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("array_access", COMPUTATION_ACCESS, NONE, NONE, 0)
/** @} */

// =============================================================================
// TYPE SYSTEM
// =============================================================================

/**
 * @defgroup java_type_system Type System
 * @brief Type references, primitives, generics, and arrays
 *
 * Java has both primitive types and reference types:
 * - Primitives: `int`, `boolean`, `float`, etc. (TYPE_PRIMITIVE)
 * - Reference types: Classes, interfaces, arrays (TYPE_REFERENCE)
 * - Generics: Type parameters `<T>` (TYPE_GENERIC)
 * - Arrays: `Type[]` (TYPE_COMPOSITE)
 *
 * The `void` keyword is also treated as a type for return type declarations.
 * @{
 */

// Type references
DEF_TYPE("type_identifier", TYPE_REFERENCE, NODE_TEXT, NONE, 0)
DEF_TYPE("scoped_type_identifier", TYPE_REFERENCE, NODE_TEXT, NONE, 0)

// Primitive types
DEF_TYPE("integral_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("floating_point_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("boolean_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("void_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)

// Composite and generic types
DEF_TYPE("array_type", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("dimensions", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("generic_type", TYPE_GENERIC, NODE_TEXT, NONE, 0)
DEF_TYPE("type_arguments", TYPE_GENERIC, NONE, NONE, 0)
/** @} */

// =============================================================================
// OPERATORS AND EXPRESSIONS
// =============================================================================

/**
 * @defgroup java_operators Operators and Expressions
 * @brief Arithmetic, logical, comparison, and assignment operators
 *
 * Java operators include:
 * - Arithmetic: `+`, `-`, `*`, `/`, `%`, bitwise, shifts
 * - Logical: `&&`, `||`, `!`
 * - Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`, `instanceof`
 * - Assignment: `=`, `+=`, `-=`, etc.
 * - Ternary: `? :`
 * - Update: `++`, `--` (prefix and postfix)
 *
 * Java has unsigned right shift `>>>` unlike C/C++.
 * @{
 */
DEF_TYPE("assignment_expression", OPERATOR_ASSIGNMENT | SemanticRefinements::Assignment::SIMPLE, NONE, NONE, 0)
DEF_TYPE("binary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::BINARY, NONE, NONE, 0)
DEF_TYPE("unary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)
DEF_TYPE("update_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)
DEF_TYPE("ternary_expression", FLOW_CONDITIONAL | SemanticRefinements::Conditional::TERNARY, NONE, NONE, 0)
DEF_TYPE("parenthesized_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)
/** @} */

// =============================================================================
// IDENTIFIERS AND LITERALS
// =============================================================================

/**
 * @defgroup java_identifiers Identifiers
 * @brief Identifier and scoped identifier nodes
 * @{
 */
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("scoped_identifier", NAME_QUALIFIED, NODE_TEXT, NONE, 0)
/** @} */

/**
 * @defgroup java_literals Literal Values
 * @brief Numeric, string, and boolean literals
 *
 * Java numeric literals can have various bases:
 * - Decimal: `123`
 * - Hexadecimal: `0xFF`
 * - Octal: `0777`
 * - Binary: `0b1010`
 *
 * String literals support escape sequences. Character literals use single quotes.
 * @{
 */

// Integer literals (all bases)
DEF_TYPE("decimal_integer_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)
DEF_TYPE("hex_integer_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)
DEF_TYPE("octal_integer_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)
DEF_TYPE("binary_integer_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)

// Floating point literals
DEF_TYPE("decimal_floating_point_literal", LITERAL_NUMBER | SemanticRefinements::Number::FLOAT, NODE_TEXT, NONE, 0)
DEF_TYPE("hex_floating_point_literal", LITERAL_NUMBER | SemanticRefinements::Number::FLOAT, NODE_TEXT, NONE, 0)

// Boolean and null literals
DEF_TYPE("true", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("false", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("null_literal", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

// String and character literals
DEF_TYPE("string_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("string_fragment", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("character_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// CONTROL FLOW
// =============================================================================

/**
 * @defgroup java_control Control Flow
 * @brief Conditionals, loops, and jump statements
 *
 * Java control flow constructs:
 * - `if`/`else`: Binary conditional
 * - `switch`: Multiway branching (statements and expressions)
 * - `while`/`do-while`: Condition-based loops
 * - `for`: Traditional counter-based loop
 * - `enhanced_for`: Iterator-based for-each loop
 *
 * Loop refinements:
 * - COUNTER: Traditional `for(int i=0; i<n; i++)`
 * - ITERATOR: Enhanced for `for(Type x : collection)`
 * - CONDITIONAL: `while` and `do-while` loops
 * @{
 */

// Conditional statements
DEF_TYPE("if_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)
DEF_TYPE("switch_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)
DEF_TYPE("switch_expression", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)

// Loop statements
DEF_TYPE("while_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("do_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("for_statement", FLOW_LOOP | SemanticRefinements::Loop::COUNTER, NONE, NONE, 0)
DEF_TYPE("enhanced_for_statement", FLOW_LOOP | SemanticRefinements::Loop::ITERATOR, NONE, NONE, 0)

// Jump statements
DEF_TYPE("break_statement", FLOW_JUMP | SemanticRefinements::Jump::BREAK, NONE, NONE, 0)
DEF_TYPE("continue_statement", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)
DEF_TYPE("return_statement", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, NONE, 0)
DEF_TYPE("yield_statement", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, NONE, 0)
/** @} */

// =============================================================================
// EXCEPTION HANDLING
// =============================================================================

/**
 * @defgroup java_exceptions Exception Handling
 * @brief Try/catch/finally and throw statements
 *
 * Java has checked exceptions that must be declared or caught. The
 * `try_with_resources_statement` (Java 7+) automatically closes resources.
 *
 * Exception types:
 * - ERROR_TRY: `try` and `try-with-resources` blocks
 * - ERROR_CATCH: `catch` clauses
 * - ERROR_FINALLY: `finally` blocks
 * - ERROR_THROW: `throw` statements and `throws` declarations
 * @{
 */
DEF_TYPE("try_statement", ERROR_TRY, NONE, NONE, 0)
DEF_TYPE("try_with_resources_statement", ERROR_TRY, NONE, NONE, 0)
DEF_TYPE("catch_clause", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("catch_type", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("finally_clause", ERROR_FINALLY, NONE, NONE, 0)
DEF_TYPE("throw_statement", ERROR_THROW, NONE, NONE, 0)
/** @} */

// =============================================================================
// ANNOTATIONS
// =============================================================================

/**
 * @defgroup java_annotations Annotations
 * @brief Java annotation syntax
 *
 * Annotations provide metadata for classes, methods, and fields.
 * Common annotations: `@Override`, `@Deprecated`, `@SuppressWarnings`.
 *
 * - `marker_annotation`: Annotation without arguments (`@Override`)
 * - `annotation`: Annotation with arguments (`@SuppressWarnings("unchecked")`)
 * @{
 */
DEF_TYPE("annotation", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("marker_annotation", METADATA_ANNOTATION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("annotation_argument_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("@", NAME_ATTRIBUTE, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// MODIFIERS
// =============================================================================

/**
 * @defgroup java_modifiers Modifiers
 * @brief Access modifiers and other modifier keywords
 *
 * Java modifiers control visibility and behavior:
 * - Access: `public`, `private`, `protected` (default is package-private)
 * - Other: `static`, `final`, `abstract`, `synchronized`, `volatile`, etc.
 *
 * Modifiers are children of declaration nodes and affect their semantics.
 * @{
 */
DEF_TYPE("modifiers", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("modifier", METADATA_ANNOTATION, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// COMMENTS
// =============================================================================

/// @defgroup java_comments Comments
/// @brief Line and block comments
///
/// Java has line comments and block comments.
/// Javadoc comments are a special form of block comments.
/// @{
DEF_TYPE("line_comment", METADATA_COMMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("block_comment", METADATA_COMMENT, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// STRUCTURAL ELEMENTS
// =============================================================================

/**
 * @defgroup java_structure Structural Elements
 * @brief Blocks, lists, and organizational nodes
 * @{
 */
DEF_TYPE("block", ORGANIZATION_BLOCK | SemanticRefinements::Organization::SEQUENTIAL, NONE, NONE, 0)
DEF_TYPE("class_body", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("interface_body", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("enum_body", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("constructor_body", ORGANIZATION_BLOCK, NONE, NONE, 0)
DEF_TYPE("argument_list", ORGANIZATION_LIST | SemanticRefinements::Organization::COLLECTION, NONE, NONE, 0)
DEF_TYPE("formal_parameters", ORGANIZATION_LIST | SemanticRefinements::Organization::COLLECTION, NONE, NONE, 0)
DEF_TYPE("expression_statement", EXECUTION_STATEMENT, NONE, NONE, 0)
/** @} */

// =============================================================================
// KEYWORDS
// =============================================================================

/**
 * @defgroup java_keywords Keywords
 * @brief Java reserved words as syntax tokens
 *
 * Keywords are marked with IS_KEYWORD flag and get the same semantic type
 * as the constructs they introduce. This enables semantic queries that include
 * or exclude keyword tokens as needed.
 * @{
 */

// Access modifier keywords
DEF_TYPE("public", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("private", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("protected", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Other modifier keywords
DEF_TYPE("static", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("final", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("abstract", METADATA_ANNOTATION, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Type definition keywords
DEF_TYPE("class", DEFINITION_CLASS, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("interface", DEFINITION_CLASS, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("enum", DEFINITION_CLASS, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("extends", TYPE_REFERENCE, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("implements", TYPE_REFERENCE, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Package and import keywords
DEF_TYPE("package", DEFINITION_MODULE, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("import", EXTERNAL_IMPORT, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Control flow keywords
DEF_TYPE("if", FLOW_CONDITIONAL, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("for", FLOW_LOOP, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("return", FLOW_JUMP, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Exception keywords
DEF_TYPE("try", ERROR_TRY, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("catch", ERROR_CATCH, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("throw", ERROR_THROW, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("throws", ERROR_THROW, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Object keywords
DEF_TYPE("new", COMPUTATION_CALL, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("this", NAME_SCOPED, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("super", NAME_SCOPED, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("instanceof", OPERATOR_COMPARISON, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)

// Primitive type keywords
DEF_TYPE("int", TYPE_PRIMITIVE, NODE_TEXT, NONE, ASTNodeFlags::IS_KEYWORD)
/** @} */

// =============================================================================
// OPERATORS
// =============================================================================

/**
 * @defgroup java_operators_tokens Operator Tokens
 * @brief Individual operator symbols
 * @{
 */

// Assignment operators
DEF_TYPE("=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("+=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("-=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("*=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("/=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("%=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("&=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("|=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("^=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("<<=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE(">>=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE(">>>=", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)
DEF_TYPE("->", OPERATOR_ASSIGNMENT, NODE_TEXT, NONE, 0)

// Comparison operators
DEF_TYPE("==", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)
DEF_TYPE("!=", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)
DEF_TYPE("<", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)
DEF_TYPE(">", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)
DEF_TYPE("<=", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)
DEF_TYPE(">=", OPERATOR_COMPARISON, NODE_TEXT, NONE, 0)

// Arithmetic operators
DEF_TYPE("+", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("-", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("*", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("/", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("%", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("&", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("|", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("^", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("~", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("<<", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE(">>", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE(">>>", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("++", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)
DEF_TYPE("--", OPERATOR_ARITHMETIC, NODE_TEXT, NONE, 0)

// Logical operators
DEF_TYPE("&&", OPERATOR_LOGICAL, NODE_TEXT, NONE, 0)
DEF_TYPE("||", OPERATOR_LOGICAL, NODE_TEXT, NONE, 0)
DEF_TYPE("!", OPERATOR_LOGICAL, NODE_TEXT, NONE, 0)

// Other operators
DEF_TYPE("?", FLOW_CONDITIONAL, NODE_TEXT, NONE, 0)
DEF_TYPE("::", COMPUTATION_ACCESS, NODE_TEXT, NONE, 0)
/** @} */

// =============================================================================
// PUNCTUATION AND DELIMITERS
// =============================================================================

/**
 * @defgroup java_punctuation Punctuation
 * @brief Delimiters, separators, and syntax markers
 * @{
 */
DEF_TYPE("(", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE(")", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("[", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("]", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("{", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("}", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("\"", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE("'", PARSER_DELIMITER, NODE_TEXT, NONE, 0)
DEF_TYPE(",", PARSER_PUNCTUATION, NODE_TEXT, NONE, 0)
DEF_TYPE(";", PARSER_PUNCTUATION, NODE_TEXT, NONE, 0)
DEF_TYPE(".", PARSER_PUNCTUATION, NODE_TEXT, NONE, 0)
DEF_TYPE(":", PARSER_PUNCTUATION, NODE_TEXT, NONE, 0)
/** @} */
