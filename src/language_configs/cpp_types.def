// C++ node type mappings
// Format: DEF_TYPE(raw_type, semantic_type, name_extraction, value_extraction, flags)

// Function definitions with refinements
DEF_TYPE("function_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_QUALIFIED_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("function_declarator", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("method_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("constructor_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("destructor_definition", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("lambda_expression", DEFINITION_FUNCTION | SemanticRefinements::Function::LAMBDA, FIND_ASSIGNMENT_TARGET, ARROW_FUNCTION, 0)

// Class/struct definitions
DEF_TYPE("class_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)
DEF_TYPE("struct_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)
DEF_TYPE("union_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)
DEF_TYPE("enum_specifier", DEFINITION_CLASS, FIND_IDENTIFIER, CLASS_WITH_METHODS, 0)

// Variable declarations with refinements
DEF_TYPE("declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("parameter_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("field_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, NONE, 0)

// Namespace/module
DEF_TYPE("namespace_definition", DEFINITION_MODULE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("translation_unit", DEFINITION_MODULE, NONE, NONE, 0)

// Function calls and expressions with refinements
DEF_TYPE("call_expression", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, FIND_CALL_TARGET, FUNCTION_CALL, 0)
DEF_TYPE("new_expression", COMPUTATION_CALL | SemanticRefinements::Call::CONSTRUCTOR, FIND_CALL_TARGET, FUNCTION_CALL, 0)
DEF_TYPE("delete_expression", COMPUTATION_CALL | SemanticRefinements::Call::FUNCTION, FIND_CALL_TARGET, FUNCTION_CALL, 0)
DEF_TYPE("binary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::BINARY, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("unary_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)
DEF_TYPE("assignment_expression", OPERATOR_ASSIGNMENT | SemanticRefinements::Assignment::SIMPLE, NONE, NONE, 0)
DEF_TYPE("update_expression", OPERATOR_ARITHMETIC | SemanticRefinements::Arithmetic::UNARY, NONE, NONE, 0)
DEF_TYPE("cast_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)

// Member access
DEF_TYPE("field_expression", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("subscript_expression", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("pointer_expression", COMPUTATION_ACCESS, NONE, NONE, 0)

// Identifiers and references
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("field_identifier", NAME_IDENTIFIER, NODE_TEXT, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("namespace_identifier", NAME_QUALIFIED, NODE_TEXT, NONE, 0)
DEF_TYPE("qualified_identifier", NAME_QUALIFIED, NODE_TEXT, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("scoped_identifier", NAME_SCOPED, NODE_TEXT, NONE, 0)

// Types
DEF_TYPE("primitive_type", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("type_identifier", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("sized_type_specifier", TYPE_PRIMITIVE, NODE_TEXT, NONE, 0)
DEF_TYPE("struct_type", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("union_type", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("pointer_type", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("reference_type", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("template_type", TYPE_GENERIC, NONE, NONE, 0)
DEF_TYPE("auto", TYPE_GENERIC, NONE, NONE, 0)

// Literals with refinements - name and value both contain the literal text
DEF_TYPE("string_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("raw_string_literal", LITERAL_STRING | SemanticRefinements::String::RAW, NODE_TEXT, NONE, 0)
DEF_TYPE("char_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)
DEF_TYPE("number_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)
DEF_TYPE("true", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("false", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("nullptr", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("null", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)
DEF_TYPE("initializer_list", LITERAL_STRUCTURED | SemanticRefinements::Structured::SEQUENCE, NONE, NONE, 0)

// Control flow with refinements
DEF_TYPE("if_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)
DEF_TYPE("switch_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)
DEF_TYPE("conditional_expression", FLOW_CONDITIONAL | SemanticRefinements::Conditional::TERNARY, NONE, NONE, 0)
DEF_TYPE("for_statement", FLOW_LOOP | SemanticRefinements::Loop::COUNTER, NONE, NONE, 0)
DEF_TYPE("for_range_loop", FLOW_LOOP | SemanticRefinements::Loop::ITERATOR, NONE, NONE, 0)
DEF_TYPE("while_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("do_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("return_statement", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("break_statement", FLOW_JUMP | SemanticRefinements::Jump::BREAK, NONE, NONE, 0)
DEF_TYPE("continue_statement", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)
DEF_TYPE("goto_statement", FLOW_JUMP | SemanticRefinements::Jump::GOTO, NONE, NONE, 0)

// Async/sync constructs (C++20)
DEF_TYPE("co_await_expression", FLOW_SYNC, NONE, NONE, 0)
DEF_TYPE("co_yield_expression", FLOW_SYNC, NONE, NONE, 0)
DEF_TYPE("co_return_statement", FLOW_SYNC, NONE, NONE, 0)

// Error handling
DEF_TYPE("try_statement", ERROR_TRY, NONE, NONE, 0)
DEF_TYPE("catch_clause", ERROR_CATCH, NONE, NONE, 0)
DEF_TYPE("throw_statement", ERROR_THROW, NONE, NONE, 0)

// Structure/Organization
DEF_TYPE("compound_statement", ORGANIZATION_BLOCK, NONE, VARIABLE_WITH_TYPE, 0)
DEF_TYPE("parameter_list", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("argument_list", ORGANIZATION_LIST, NONE, FUNCTION_WITH_PARAMS, 0)
DEF_TYPE("template_parameter_list", ORGANIZATION_LIST, NONE, NONE, 0)

// External/Import
DEF_TYPE("preproc_include", EXTERNAL_IMPORT, NONE, NONE, 0)
DEF_TYPE("using_declaration", EXTERNAL_IMPORT, NONE, NONE, 0)

// Preprocessor/Metadata
DEF_TYPE("preproc_def", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("preproc_ifdef", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("preproc_ifndef", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("comment", METADATA_COMMENT, NONE, NONE, 0)

// ====================================
// PUNCTUATION TOKENS (12.2M misclassified nodes fix)
// ====================================

// Punctuation marks
DEF_TYPE(",", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(";", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(".", PARSER_PUNCTUATION, NONE, NONE, 0)
DEF_TYPE(":", PARSER_PUNCTUATION, NONE, NONE, 0)

// Delimiters
DEF_TYPE("(", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE(")", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("[", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("]", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("{", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("}", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("\"", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("'", PARSER_DELIMITER, NONE, NONE, 0)

// Assignment operators
DEF_TYPE("=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("+=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("-=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("*=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("/=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("%=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("&=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("|=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("^=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE("<<=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)
DEF_TYPE(">>=", OPERATOR_ASSIGNMENT, NONE, NONE, 0)

// Comparison operators
DEF_TYPE("==", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("!=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE("<=", OPERATOR_COMPARISON, NONE, NONE, 0)
DEF_TYPE(">=", OPERATOR_COMPARISON, NONE, NONE, 0)

// Arithmetic operators
DEF_TYPE("+", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("-", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("*", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("/", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("%", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("&", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("|", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("^", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("~", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("<<", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE(">>", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("++", OPERATOR_ARITHMETIC, NONE, NONE, 0)
DEF_TYPE("--", OPERATOR_ARITHMETIC, NONE, NONE, 0)

// Logical operators
DEF_TYPE("&&", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("||", OPERATOR_LOGICAL, NONE, NONE, 0)
DEF_TYPE("!", OPERATOR_LOGICAL, NONE, NONE, 0)

// Member access
DEF_TYPE("->", COMPUTATION_ACCESS, NONE, NONE, 0)
DEF_TYPE("::", COMPUTATION_ACCESS, NONE, NONE, 0)

// C++ specific structural elements
DEF_TYPE("template_argument_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("subscript_argument_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("init_declarator", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("type_descriptor", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("reference_declarator", TYPE_REFERENCE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("condition_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("pointer_declarator", TYPE_COMPOSITE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("parenthesized_expression", COMPUTATION_EXPRESSION, NONE, NONE, 0)
DEF_TYPE("array_declarator", TYPE_COMPOSITE, FIND_IDENTIFIER, NONE, 0)

// C++ Keywords
DEF_TYPE("if", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("else", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("while", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("for", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("do", FLOW_LOOP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("switch", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("case", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("default", FLOW_CONDITIONAL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("break", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("continue", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("return", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("goto", FLOW_JUMP, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("try", ERROR_TRY, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("catch", ERROR_CATCH, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("throw", ERROR_THROW, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("const", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("static", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("extern", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD | ASTNodeFlags::IS_PUBLIC)
DEF_TYPE("inline", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("virtual", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("override", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("final", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("public", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD | ASTNodeFlags::IS_PUBLIC)
DEF_TYPE("private", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("protected", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("class", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("struct", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("union", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("enum", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("namespace", DEFINITION_MODULE, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("using", EXTERNAL_IMPORT, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("typedef", DEFINITION_CLASS, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("typename", TYPE_GENERIC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("template", PATTERN_TEMPLATE, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("sizeof", OPERATOR_ARITHMETIC, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("new", COMPUTATION_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("delete", COMPUTATION_CALL, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("this", NAME_SCOPED, NONE, NONE, 0)
DEF_TYPE("nullptr", LITERAL_ATOMIC, NONE, NONE, 0)
DEF_TYPE("true", LITERAL_ATOMIC, NONE, NONE, 0)
DEF_TYPE("false", LITERAL_ATOMIC, NONE, NONE, 0)

// Preprocessor directives
DEF_TYPE("#include", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#define", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#ifdef", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#ifndef", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#if", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#else", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#elif", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#endif", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#undef", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("#pragma", METADATA_DIRECTIVE, NONE, NONE, 0)

// String/character content
DEF_TYPE("string_content", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("escape_sequence", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("character", LITERAL_STRING, NODE_TEXT, NONE, 0)

// C++ specific constructs
DEF_TYPE("template_function", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("case_statement", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("else_clause", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("type_qualifier", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("storage_class_specifier", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("placeholder_type_specifier", TYPE_GENERIC, NONE, NONE, 0)
DEF_TYPE("expression_statement", EXECUTION_STATEMENT, NONE, VARIABLE_WITH_TYPE, 0)

// C++ perfection - remaining 1,408 unclassified nodes
DEF_TYPE("virtual_specifier", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("constexpr", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("access_specifier", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("compound_literal_expression", LITERAL_STRUCTURED, NONE, NONE, 0)
DEF_TYPE("declaration_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("field_declaration_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("field_initializer", LITERAL_STRUCTURED, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("system_lib_string", EXTERNAL_IMPORT, NODE_TEXT, NONE, 0)
DEF_TYPE("optional_parameter_declaration", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("preproc_arg", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("template_method", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("?", FLOW_CONDITIONAL, NONE, NONE, 0)
DEF_TYPE("lambda_capture_specifier", COMPUTATION_CLOSURE, NONE, NONE, 0)
DEF_TYPE("lambda_declarator", COMPUTATION_CLOSURE, NONE, NONE, 0)
DEF_TYPE("preproc_call", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("preproc_directive", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("enumerator", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("base_class_clause", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("abstract_pointer_declarator", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("linkage_specification", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("field_initializer_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("abstract_reference_declarator", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("trailing_return_type", TYPE_REFERENCE, NONE, NONE, 0)
DEF_TYPE("lambda_default_capture", COMPUTATION_CLOSURE, NONE, NONE, 0)
DEF_TYPE("preproc_params", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("preproc_function_def", DEFINITION_FUNCTION, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("default_method_clause", DEFINITION_FUNCTION, NONE, NONE, 0)
DEF_TYPE("operator", DEFINITION_FUNCTION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("raw_string_delimiter", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("operator_name", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("raw_string_content", LITERAL_STRING, NODE_TEXT, NONE, 0)
DEF_TYPE("R\"", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("noexcept", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("destructor_name", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)
DEF_TYPE("delete_method_clause", DEFINITION_FUNCTION, NONE, NONE, 0)
DEF_TYPE("mutable", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("alias_declaration", DEFINITION_VARIABLE, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("enumerator_list", ORGANIZATION_LIST, NONE, NONE, 0)
DEF_TYPE("type_parameter_declaration", TYPE_GENERIC, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("template_declaration", PATTERN_TEMPLATE, NONE, NONE, 0)
DEF_TYPE("type_definition", DEFINITION_CLASS, FIND_IDENTIFIER, NONE, 0)
DEF_TYPE("()", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("abstract_function_declarator", TYPE_COMPOSITE, NONE, NONE, 0)
DEF_TYPE("explicit_function_specifier", METADATA_ANNOTATION, NONE, NONE, 0)
DEF_TYPE("preproc_else", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("\n", PARSER_DELIMITER, NONE, NONE, 0)
DEF_TYPE("preproc_if", METADATA_DIRECTIVE, NONE, NONE, 0)
DEF_TYPE("explicit", METADATA_ANNOTATION, NONE, NONE, ASTNodeFlags::IS_KEYWORD)
DEF_TYPE("concatenated_string", LITERAL_STRING, NODE_TEXT, NONE, 0)

// ==============================================================================
// Parser-level semantic mappings only
// Note: STL algorithm names (transform, sort, find, etc.) are removed 
// since they're just identifiers - could be user-defined functions with different semantics
// ==============================================================================

// Error handling
DEF_TYPE("ERROR", PARSER_SYNTAX, NONE, NONE, 0)