/**
 * @file csharp_types.def
 * @brief C# language node type mappings for AST semantic extraction
 *
 * @details This file defines how tree-sitter C# AST node types map to semantic
 * categories used by the sitting_duck extension. Each mapping specifies the semantic
 * classification, name extraction strategy, native context extraction, and behavioral
 * flags for C# language constructs.
 *
 * ## C# Language Characteristics
 *
 * - **.NET language**: Runs on CLR, interoperable with .NET ecosystem
 * - **Type system**: Strong static typing with generics
 * - **Classes**: Single inheritance with multiple interface implementation
 * - **Structs**: Value types for performance-critical code
 * - **Records**: Immutable reference types (C# 9+)
 * - **Properties**: First-class with get/set accessors
 * - **LINQ**: Language-integrated query expressions
 * - **Async/await**: First-class async programming support
 * - **Pattern matching**: Enhanced switch expressions (C# 8+)
 * - **Nullable reference types**: Compile-time null safety (C# 8+)
 *
 * ## Semantic Type Encoding
 *
 * Semantic types use an 8-bit encoding:
 * - Bits 7-2: Base semantic category (e.g., DEFINITION_CLASS = 0x08)
 * - Bits 1-0: Refinement within category (e.g., Class::REGULAR = 0x00)
 *
 * ## DEF_TYPE Macro Parameters
 *
 * ```cpp
 * DEF_TYPE(raw_type, semantic_type, name_extraction, native_extraction, flags)
 * ```
 *
 * | Parameter | Description |
 * |-----------|-------------|
 * | raw_type | Tree-sitter node type string |
 * | semantic_type | Semantic category with optional refinement |
 * | name_extraction | Strategy for extracting node name |
 * | native_extraction | Strategy for rich context extraction |
 * | flags | Behavioral flags (IS_CONSTRUCT, IS_KEYWORD, IS_EMBODIED, etc.) |
 *
 * @see python_types.def for the comprehensive documentation template
 * @see node_config.hpp for ExtractionStrategy and NativeExtractionStrategy enums
 * @see semantic_types.hpp for semantic type constants
 */

// ============================================================================
// PROGRAM STRUCTURE
// ============================================================================

/**
 * @defgroup csharp_program Program Structure
 * @brief Top-level file structure
 *
 * C# file organization:
 * - `using` directives at top
 * - `namespace` declarations organize code
 * - File-scoped namespaces (C# 10+): `namespace Name;`
 * @{
 */

/// @brief Compilation unit - root node for C# file
DEF_TYPE("compilation_unit", DEFINITION_MODULE, NONE, NONE, ASTNodeFlags::IS_CONSTRUCT)

/// @brief Namespace declaration - `namespace Name { }`
DEF_TYPE("namespace_declaration", DEFINITION_MODULE, FIND_IDENTIFIER, NONE, ASTNodeFlags::IS_CONSTRUCT)

/** @} */ // end csharp_program

// ============================================================================
// USING STATEMENTS
// ============================================================================

/**
 * @defgroup csharp_using Using Statements
 * @brief Import and namespace directives
 *
 * C# using features:
 * - `using Namespace;` - import namespace
 * - `using static Class;` - import static members
 * - `using Alias = Type;` - type alias
 * - `global using` - file-scoped (C# 10+)
 * @{
 */

/// @brief Using directive - `using System;`
DEF_TYPE("using_directive", EXTERNAL_IMPORT | SemanticRefinements::Import::MODULE, FIND_IDENTIFIER, NONE, 0)

/** @} */ // end csharp_using

// ============================================================================
// METHOD DEFINITIONS
// ============================================================================

/**
 * @defgroup csharp_methods Method Definitions
 * @brief C# method and function declarations
 *
 * C# method features:
 * - `public Type Method(params) { }`
 * - `ref` and `out` parameters
 * - `params` for variadic parameters
 * - Expression-bodied: `int Foo() => 42;`
 * - Local functions: nested function definitions
 * - `async` methods for asynchronous programming
 * @{
 */

/// @brief Method declaration - class method
DEF_TYPE("method_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Constructor declaration - `ClassName(params) { }`
DEF_TYPE("constructor_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Destructor/finalizer - `~ClassName() { }`
DEF_TYPE("destructor_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::CONSTRUCTOR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Operator overload - `public static T operator+(T a, T b)`
DEF_TYPE("operator_declaration", DEFINITION_FUNCTION | SemanticRefinements::Function::REGULAR, FIND_IDENTIFIER, FUNCTION_WITH_PARAMS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Lambda expression - `(x) => x * 2`
DEF_TYPE("lambda_expression", DEFINITION_FUNCTION | SemanticRefinements::Function::LAMBDA, FIND_ASSIGNMENT_TARGET, ARROW_FUNCTION, ASTNodeFlags::IS_EMBODIED)

/** @} */ // end csharp_methods

// ============================================================================
// CLASS AND TYPE DEFINITIONS
// ============================================================================

/**
 * @defgroup csharp_classes Class and Type Definitions
 * @brief C# type declarations
 *
 * C# type kinds:
 * - `class` - reference type with single inheritance
 * - `struct` - value type, no inheritance
 * - `interface` - contract definition
 * - `enum` - enumeration type
 * - `record` - immutable reference type (C# 9+)
 * - `record struct` - immutable value type (C# 10+)
 * @{
 */

/// @brief Class declaration - reference type
DEF_TYPE("class_declaration", DEFINITION_CLASS | SemanticRefinements::Class::REGULAR, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Struct declaration - value type
DEF_TYPE("struct_declaration", DEFINITION_CLASS | SemanticRefinements::Class::REGULAR, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Interface declaration - contract
DEF_TYPE("interface_declaration", DEFINITION_CLASS | SemanticRefinements::Class::ABSTRACT, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Enum declaration - enumeration
DEF_TYPE("enum_declaration", DEFINITION_CLASS | SemanticRefinements::Class::ENUM, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/// @brief Record declaration - immutable reference type (C# 9+)
DEF_TYPE("record_declaration", DEFINITION_CLASS | SemanticRefinements::Class::REGULAR, FIND_IDENTIFIER, CLASS_WITH_METHODS, ASTNodeFlags::IS_CONSTRUCT | ASTNodeFlags::IS_EMBODIED)

/** @} */ // end csharp_classes

// ============================================================================
// VARIABLE AND PROPERTY DECLARATIONS
// ============================================================================

/**
 * @defgroup csharp_variables Variable and Property Declarations
 * @brief Fields, properties, and local variables
 *
 * C# member types:
 * - Fields: `private int _field;`
 * - Properties: `public int Property { get; set; }`
 * - Auto-properties: `public int Prop { get; set; }`
 * - Init-only: `public int Prop { get; init; }` (C# 9+)
 * @{
 */

/// @brief Field declaration - class field
DEF_TYPE("field_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, ASTNodeFlags::IS_CONSTRUCT)

/// @brief Property declaration - get/set accessor
DEF_TYPE("property_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::FIELD, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, ASTNodeFlags::IS_CONSTRUCT)

/// @brief Local variable declaration
DEF_TYPE("variable_declaration", DEFINITION_VARIABLE | SemanticRefinements::Variable::MUTABLE, FIND_IDENTIFIER, VARIABLE_WITH_TYPE, 0)

/// @brief Method parameter
DEF_TYPE("parameter", DEFINITION_VARIABLE | SemanticRefinements::Variable::PARAMETER, FIND_IDENTIFIER, NONE, 0)

/** @} */ // end csharp_variables

// ============================================================================
// FUNCTION CALLS AND EXPRESSIONS
// ============================================================================

/**
 * @defgroup csharp_calls Function Calls and Expressions
 * @brief Method invocations and expressions
 * @{
 */

/// @brief Method invocation - `obj.Method(args)`
DEF_TYPE("invocation_expression", COMPUTATION_CALL | SemanticRefinements::Call::METHOD, FIND_CALL_TARGET, FUNCTION_CALL, 0)

/// @brief Object creation - `new ClassName(args)`
DEF_TYPE("object_creation_expression", COMPUTATION_CALL | SemanticRefinements::Call::CONSTRUCTOR, FIND_CALL_TARGET, FUNCTION_CALL, 0)

/** @} */ // end csharp_calls

// ============================================================================
// CONTROL FLOW
// ============================================================================

/**
 * @defgroup csharp_control Control Flow
 * @brief Conditionals and branching
 *
 * C# control flow:
 * - `if`/`else if`/`else` - standard conditional
 * - `switch` with pattern matching (C# 8+)
 * - Switch expressions: `x switch { pattern => value }`
 * @{
 */

/// @brief If statement - `if (cond) { }`
DEF_TYPE("if_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::BINARY, NONE, NONE, 0)

/// @brief Switch statement - pattern matching
DEF_TYPE("switch_statement", FLOW_CONDITIONAL | SemanticRefinements::Conditional::MULTIWAY, NONE, NONE, 0)

/** @} */ // end csharp_control

// ============================================================================
// LOOP CONSTRUCTS
// ============================================================================

/**
 * @defgroup csharp_loops Loop Constructs
 * @brief Iteration mechanisms
 *
 * C# loops:
 * - `for (init; cond; incr)` - classic for
 * - `foreach (var x in collection)` - iterator
 * - `while (cond)` - pre-condition
 * - `do { } while (cond)` - post-condition
 * @{
 */

/// @brief For statement - `for (int i = 0; i < n; i++)`
DEF_TYPE("for_statement", FLOW_LOOP | SemanticRefinements::Loop::COUNTER, NONE, NONE, 0)

/// @brief Foreach statement - `foreach (var x in collection)`
DEF_TYPE("foreach_statement", FLOW_LOOP | SemanticRefinements::Loop::ITERATOR, NONE, NONE, 0)

/// @brief While statement - `while (cond) { }`
DEF_TYPE("while_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)

/// @brief Do statement - `do { } while (cond);`
DEF_TYPE("do_statement", FLOW_LOOP | SemanticRefinements::Loop::CONDITIONAL, NONE, NONE, 0)

/** @} */ // end csharp_loops

// ============================================================================
// JUMP STATEMENTS
// ============================================================================

/**
 * @defgroup csharp_jumps Jump Statements
 * @brief Control flow transfer
 * @{
 */

/// @brief Break statement - exits loop or switch
DEF_TYPE("break_statement", FLOW_JUMP | SemanticRefinements::Jump::BREAK, NONE, NONE, 0)

/// @brief Continue statement - skips to next iteration
DEF_TYPE("continue_statement", FLOW_JUMP | SemanticRefinements::Jump::CONTINUE, NONE, NONE, 0)

/// @brief Return statement - exits method with value
DEF_TYPE("return_statement", FLOW_JUMP | SemanticRefinements::Jump::RETURN, NONE, NONE, 0)

/// @brief Throw statement - raises exception
DEF_TYPE("throw_statement", ERROR_THROW, NONE, NONE, 0)

/** @} */ // end csharp_jumps

// ============================================================================
// ERROR HANDLING
// ============================================================================

/**
 * @defgroup csharp_errors Error Handling
 * @brief Exception handling constructs
 *
 * C# exception handling:
 * - `try { } catch (Exception e) { } finally { }`
 * - Exception filters: `catch (E e) when (condition)`
 * - `throw;` to rethrow preserving stack trace
 * @{
 */

/// @brief Try statement - exception handling
DEF_TYPE("try_statement", ERROR_TRY, NONE, NONE, 0)

/// @brief Catch clause - handles exceptions
DEF_TYPE("catch_clause", ERROR_CATCH, NONE, NONE, 0)

/// @brief Finally clause - always executed
DEF_TYPE("finally_clause", ERROR_FINALLY, NONE, NONE, 0)

/** @} */ // end csharp_errors

// ============================================================================
// ASYNC/AWAIT
// ============================================================================

/**
 * @defgroup csharp_async Async/Await
 * @brief Asynchronous programming support
 *
 * C# async features:
 * - `async` modifier on methods
 * - `await` for asynchronous operations
 * - Returns `Task`, `Task<T>`, or `ValueTask<T>`
 * @{
 */

/// @brief Await expression - `await asyncOperation`
DEF_TYPE("await_expression", FLOW_SYNC, NONE, NONE, 0)

/** @} */ // end csharp_async

// ============================================================================
// IDENTIFIERS AND LITERALS
// ============================================================================

/**
 * @defgroup csharp_literals Identifiers and Literals
 * @brief Names and literal values
 *
 * C# literals:
 * - Integers: `42`, `0xFF`, `42L`, `42u`
 * - Floats: `3.14`, `3.14f`, `3.14m` (decimal)
 * - Strings: `"string"`, `@"verbatim"`, `$"interpolated"`
 * - Characters: `'a'`
 * - Boolean: `true`, `false`
 * - Null: `null`
 * @{
 */

/// @brief Identifier - name
DEF_TYPE("identifier", NAME_IDENTIFIER, NODE_TEXT, NONE, 0)

/// @brief Integer literal
DEF_TYPE("integer_literal", LITERAL_NUMBER | SemanticRefinements::Number::INTEGER, NODE_TEXT, NONE, 0)

/// @brief Real/float literal
DEF_TYPE("real_literal", LITERAL_NUMBER | SemanticRefinements::Number::FLOAT, NODE_TEXT, NONE, 0)

/// @brief String literal
DEF_TYPE("string_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)

/// @brief Character literal - `'a'`
DEF_TYPE("character_literal", LITERAL_STRING | SemanticRefinements::String::LITERAL, NODE_TEXT, NONE, 0)

/// @brief Boolean literal - `true` or `false`
DEF_TYPE("boolean_literal", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/// @brief Null literal
DEF_TYPE("null_literal", LITERAL_ATOMIC, NODE_TEXT, NONE, 0)

/** @} */ // end csharp_literals

// ============================================================================
// COMMENTS
// ============================================================================

/**
 * @defgroup csharp_comments Comments
 * @brief Documentation and annotation
 *
 * C# comment styles:
 * - `// line comment`
 * - `/* block comment */`
 * - `/// <summary>XML doc</summary>`
 * @{
 */

/// @brief Comment
DEF_TYPE("comment", METADATA_COMMENT, NODE_TEXT, NONE, ASTNodeFlags::IS_CONSTRUCT)

/** @} */ // end csharp_comments

// ============================================================================
// PARSER ERROR HANDLING
// ============================================================================

/**
 * @defgroup csharp_parser_errors Parser Error Handling
 * @brief Parser error nodes
 * @{
 */

/// @brief Parse error node
DEF_TYPE("ERROR", PARSER_SYNTAX, NODE_TEXT, NONE, 0)

/** @} */ // end csharp_parser_errors
